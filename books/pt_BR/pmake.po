# Danilo G. Baio <dbaio@FreeBSD.org>, 2018. #zanata
# ELIANE FERREIRA VIDAL <naruvidal@gmail.com>, 2018. #zanata
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2018-12-08 14:50-0200\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"PO-Revision-Date: 2018-12-28 02:13+0000\n"
"Last-Translator: ELIANE FERREIRA VIDAL <naruvidal@gmail.com>\n"
"Language-Team: Portuguese (Brazil)\n"
"Language: pt_BR\n"
"X-Generator: Zanata 4.6.2\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"

#. Put one translator per line, in the form NAME <EMAIL>, YEAR1, YEAR2
msgctxt "_"
msgid "translator-credits"
msgstr ""

#. (itstool) path: info/title
#: book.translate.xml:17
msgid "PMake — A Tutorial"
msgstr ""

#. (itstool) path: info/author
#: book.translate.xml:20
msgid ""
"<personname><firstname>Adam</firstname><surname>de Boor</surname></"
"personname>"
msgstr ""
"<personname><firstname>Adam</firstname><surname>de Boor</surname></"
"personname>"

#. (itstool) path: info/copyright
#: book.translate.xml:22
msgid "<year>1988</year> <year>1989</year> <holder>Adam de Boor</holder>"
msgstr "<year>1988</year> <year>1989</year> <holder>Adam de Boor</holder>"

#. (itstool) path: info/copyright
#: book.translate.xml:28
msgid "<year>1989</year> <holder>Berkeley Softworks</holder>"
msgstr "<year>1989</year> <holder>Berkeley Softworks</holder>"

#. (itstool) path: info/copyright
#: book.translate.xml:33
msgid ""
"<year>1988</year> <year>1989</year> <year>1993</year> <holder>The Regents of "
"the University of California.</holder>"
msgstr ""
"<year>1988</year> <year>1989</year> <year>1993</year> <holder>The Regents of "
"the University of California.</holder>"

#. (itstool) path: legalnotice/para
#: book.translate.xml:45
msgid "All rights reserved."
msgstr "Todos os direitos reservados."

#. (itstool) path: legalnotice/para
#: book.translate.xml:47
msgid ""
"This code is derived from software contributed to Berkeley by Adam de Boor."
msgstr ""
"Este código é derivado de software contribuido a Berkeley por Adam de Boor."

#. (itstool) path: legalnotice/para
#: book.translate.xml:50
msgid ""
"Redistribution and use in source and binary forms, with or without "
"modification, are permitted provided that the following conditions are met:"
msgstr ""
"A redistribuição e o uso tanto dos binários quanto do código, com ou sem "
"modificação, são permitidos desde que as seguintes condições sejam atendidas:"
""

#. (itstool) path: listitem/para
#: book.translate.xml:56
msgid ""
"Redistributions of source code must retain the above copyright notice, this "
"list of conditions and the following disclaimer."
msgstr ""
"As redistribuições do código-fonte devem manter o aviso de direitos autorais "
"acima, esta lista de condições e a seguinte exclusão de responsabilidade."

#. (itstool) path: listitem/para
#: book.translate.xml:61
#, fuzzy
msgid ""
"Redistributions in binary form must reproduce the above copyright notice, "
"this list of conditions and the following disclaimer in the documentation "
"and/or other materials provided with the distribution."
msgstr ""
"As redistribuições em formato binário devem reproduzir o aviso de copyright "
"abaixo, esta lista de condições e a seguinte exclusão de responsabilidade na "
"documentação e / ou em outros materiais fornecidos com a distribuição."

#. (itstool) path: listitem/para
#: book.translate.xml:68
msgid ""
"Neither the name of the University nor the names of its contributors may be "
"used to endorse or promote products derived from this software without "
"specific prior written permission."
msgstr ""
"Nem o nome da Universidade nem os nomes de seus colaboradores podem ser "
"usados para endossar ou promover produtos derivados deste software sem "
"permissão prévia e específica por escrito."

#. (itstool) path: important/para
#: book.translate.xml:76
#, fuzzy
msgid ""
"THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS \"AS IS\" AND ANY "
"EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED "
"WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE "
"DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY "
"DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES "
"(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; "
"LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND "
"ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT "
"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF "
"THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
msgstr ""
"ESTE SOFTWARE É FORNECIDO PELOS REGENTES E COLABORADORES \"NO ESTADO EM QUE "
"SE ENCONTRA\" E QUAISQUER GARANTIAS EXPRESSAS OU IMPLÍCITAS, INCLUINDO, MAS "
"NÃO LIMITADAS ÀS GARANTIAS IMPLÍCITAS DE COMERCIALIZAÇÃO E ADEQUAÇÃO A UMA "
"FINALIDADE ESPECÍFICA, SÃO REJEITADAS. EM NENHUMA CIRCUNSTÂNCIA, OS REGENTES "
"OU COLABORADORES SERÃO RESPONSABILIZADOS POR QUAISQUER DANOS DIRETOS, "
"INDIRETOS, INCIDENTAIS, ESPECIAIS, EXEMPLARES OU CONSEQUÊNCIAIS (INCLUINDO, "
"MAS NÃO SE LIMITANDO A, AQUISIÇÃO DE BENS OU SERVIÇOS SUBSTITUTOS; PERDA DE "
"USO, DADOS OU LUCROS; OU INTERRUPÇÃO DE NEGÓCIOS), MESMO QUE EM DECORRÊNCIA "
"DESDE E DE QUALQUER TEORIA DE RESPONSABILIDADE, SEJA EM CONTRATO, "
"RESPONSABILIDADE ESTRITA, OU DELITO (INCLUINDO NEGLIGÊNCIA OU DE OUTRA "
"FORMA) DECORRENTE DE QUALQUER FORMA DE USO DESTE SOFTWARE, MESMO SE TENHA "
"AVISADO DA POSSIBILIDADE DE TAIS DANOS."

#. (itstool) path: info/releaseinfo
#: book.translate.xml:91
msgid ""
"$FreeBSD: head/en_US.ISO8859-1/books/pmake/book.xml 43184 2013-11-13 07:52:"
"45Z hrs $"
msgstr ""
"$FreeBSD: head/en_US.ISO8859-1/books/pmake/book.xml 43184 2013-11-13 07:52:"
"45Z hrs $"

#. (itstool) path: chapter/title
#: book.translate.xml:101
msgid "Introduction"
msgstr "Introdução"

#. (itstool) path: chapter/para
#: book.translate.xml:103
msgid ""
"<application>PMake</application> is a program for creating other programs, "
"or anything else you can think of for it to do. The basic idea behind "
"<application>PMake</application> is that, for any given system, be it a "
"program or a document or whatever, there will be some files that depend on "
"the state of other files (on when they were last modified). "
"<application>PMake</application> takes these dependencies, which you must "
"specify, and uses them to build whatever it is you want it to build."
msgstr ""

#. (itstool) path: chapter/para
#: book.translate.xml:112
msgid ""
"<application>PMake</application> is almost fully-compatible with "
"<application>Make</application>, with which you may already be familiar. "
"<application>PMake</application>'s most important feature is its ability to "
"run several different jobs at once, making the creation of systems "
"considerably faster. It also has a great deal more functionality than "
"<application>Make</application>."
msgstr ""

#. (itstool) path: chapter/para
#: book.translate.xml:119
msgid ""
"This tutorial is divided into three main sections corresponding to basic, "
"intermediate and advanced <application>PMake</application> usage. If you "
"already know <application>Make</application> well, you will only need to "
"skim <xref linkend=\"basics\"/> (there are some aspects of "
"<application>PMake</application> that I consider basic to its use that did "
"not exist in <application>Make</application>). Things in <xref linkend="
"\"shortcuts\"/> make life much easier, while those in <xref linkend=\"gods\"/"
"> are strictly for those who know what they are doing. <xref linkend="
"\"glossary\"/> has definitions for the jargon I use and <xref linkend="
"\"answers\"/> contains possible solutions to the problems presented "
"throughout the tutorial."
msgstr ""

#. (itstool) path: chapter/title
#: book.translate.xml:137
msgid "The Basics of PMake"
msgstr ""

#. (itstool) path: chapter/para
#: book.translate.xml:139
msgid ""
"<application>PMake</application> takes as input a file that tells which "
"files depend on which other files to be complete and what to do about files "
"that are <quote>out-of-date</quote>. This file is known as a "
"<quote>makefile</quote> and is usually kept in the top-most directory of the "
"system to be built. While you can call the makefile anything you want, "
"<application>PMake</application> will look for <filename>Makefile</filename> "
"and <filename>makefile</filename> (in that order) in the current directory "
"if you do not tell it otherwise. To specify a different makefile, use the "
"<option>-f</option> flag, e.g."
msgstr ""

#. (itstool) path: chapter/screen
#: book.translate.xml:151
#, no-wrap
msgid ""
"<prompt>%</prompt> <userinput>pmake -f <replaceable>program.mk</"
"replaceable></userinput>"
msgstr ""

#. (itstool) path: chapter/para
#: book.translate.xml:153
msgid "A makefile has four different types of lines in it:"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:157
msgid "File dependency specifications"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:161 book.translate.xml:1608
msgid "Creation commands"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:165 book.translate.xml:1612
msgid "Variable assignments"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:169 book.translate.xml:1616
msgid "Comments, include statements and conditional directives"
msgstr ""

#. (itstool) path: chapter/para
#: book.translate.xml:173
msgid ""
"Any line may be continued over multiple lines by ending it with a backslash. "
"The backslash, following newline and any initial whitespace on the following "
"line are compressed into a single space before the input line is examined by "
"<application>PMake</application>."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:180
msgid "Dependency Lines"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:182
msgid ""
"As mentioned in the introduction, in any system, there are dependencies "
"between the files that make up the system. For instance, in a program made "
"up of several C source files and one header file, the C files will need to "
"be re-compiled should the header file be changed. For a document of several "
"chapters and one macro file, the chapters will need to be reprocessed if any "
"of the macros changes. These are dependencies and are specified by means of "
"dependency lines in the makefile."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:191
msgid ""
"On a dependency line, there are targets and sources, separated by a one- or "
"two-character operator. The targets <quote>depend</quote> on the sources and "
"are usually created from them. Any number of targets and sources may be "
"specified on a dependency line. All the targets in the line are made to "
"depend on all the sources. Targets and sources need not be actual files, but "
"every source must be either an actual file or another target in the makefile."
" If you run out of room, use a backslash at the end of the line to continue "
"onto the next one."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:202
msgid ""
"Any file may be a target and any file may be a source, but the relationship "
"between the two (or however many) is determined by the <quote>operator</"
"quote> that separates them. Three types of operators exist: one specifies "
"that the datedness of a target is determined by the state of its sources, "
"while another specifies other files (the sources) that need to be dealt with "
"before the target can be re-created. The third operator is very similar to "
"the first, with the additional condition that the target is out-of-date if "
"it has no sources. These operations are represented by the colon, the "
"exclamation point and the double-colon, respectively, and are mutually "
"exclusive. Their exact semantics are as follows:"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:219
msgid "<literal>:</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:221
msgid ""
"If a colon is used, a target on the line is considered to be <quote>out-of-"
"date</quote> (and in need of creation) if any of the sources has been "
"modified more recently than the target, or the target does not exist. Under "
"this operation, steps will be taken to re-create the target only if it is "
"found to be out-of-date by using these two rules."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:231
msgid "<literal>!</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:233
msgid ""
"If an exclamation point is used, the target will always be re-created, but "
"this will not happen until all of its sources have been examined and re-"
"created, if necessary."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:240
msgid "<literal>::</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:242
msgid ""
"If a double-colon is used, a target is <quote>out-of-date</quote> if any of "
"the sources has been modified more recently than the target, or the target "
"does not exist, or the target has no sources. If the target is out-of-date "
"according to these rules, it will be re-created. This operator also does "
"something else to the targets, but I will go into that in the next section "
"(see <xref linkend=\"shellcmds\"/>)."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:256
msgid ""
"Enough words, now for an example. Take that C program I mentioned earlier. "
"Say there are three C files (<filename>a.c</filename>, <filename>b.c</"
"filename> and <filename>c.c</filename>) each of which includes the file "
"<filename>defs.h</filename>. The dependencies between the files could then "
"be expressed as follows:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:263
#, no-wrap
msgid ""
"program         : a.o b.o c.o\n"
"\n"
"a.o b.o c.o     : defs.h\n"
"\n"
"a.o             : a.c\n"
"\n"
"b.o             : b.c\n"
"\n"
"c.o             : c.c"
msgstr ""

#. (itstool) path: para/buildtarget
#: book.translate.xml:277
msgid "program"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:273
msgid ""
"You may be wondering at this point, where <filename>a.o</filename>, "
"<filename>b.o</filename> and <filename>c.o</filename> came in and why they "
"depend on <filename>defs.h</filename> and the C files do not. The reason is "
"quite simple: <_:buildtarget-1/> cannot be made by linking together "
"<filename>.c</filename> files—it must be made from <filename>.o</filename> "
"files. Likewise, if you change <filename>defs.h</filename>, it is not the "
"<filename>.c</filename> files that need to be re-created, it is the "
"<filename>.o</filename> files. If you think of dependencies in these "
"terms—which files (targets) need to be created from which files "
"(sources)—you should have no problems."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:287
msgid ""
"An important thing to notice about the above example, is that all the "
"<filename>.o</filename> files appear as targets on more than one line. This "
"is perfectly all right: the target is made to depend on all the sources "
"mentioned on all the dependency lines. For example, <filename>a.o</filename> "
"depends on both <filename>defs.h</filename> and <filename>a.c</filename>."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:294
msgid ""
"The order of the dependency lines in the makefile is important: the first "
"target on the first dependency line in the makefile will be the one that "
"gets made if you do not say otherwise. That is why program comes first in "
"the example makefile, above."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:300
msgid ""
"Both targets and sources may contain the standard C-Shell wildcard "
"characters (<literal>{</literal>, <literal>}</literal>, <literal>*</"
"literal>, <literal>?</literal>, <literal>[</literal>, and <literal>]</"
"literal>), but the non-curly-brace ones may only appear in the final "
"component (the file portion) of the target or source. The characters mean "
"the following things:"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:311
msgid "<literal>{}</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:313
msgid ""
"These enclose a comma-separated list of options and cause the pattern to be "
"expanded once for each element of the list. Each expansion contains a "
"different element. For example, <filename>src/{whiffle,beep,fish}.c</"
"filename> expands to the three words <filename>src/whiffle.c</filename>, "
"<filename>src/beep.c</filename>, and <filename>src/fish.c</filename>. These "
"braces may be nested and, unlike the other wildcard characters, the "
"resulting words need not be actual files. All other wildcard characters are "
"expanded using the files that exist when <application>PMake</application> is "
"started."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:328
msgid "<literal>*</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:330
msgid ""
"This matches zero or more characters of any sort. <filename>src/*.c</"
"filename> will expand to the same three words as above as long as src "
"contains those three files (and no other files that end in <filename>.c</"
"filename>).&gt;"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:338
msgid "<literal>?</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:340
msgid "Matches any single character."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:344
msgid "<literal>[]</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:346
msgid ""
"This is known as a character class and contains either a list of single "
"characters, or a series of character ranges (<literal>a-z</literal>, for "
"example means all characters between <literal>a</literal> and <literal>z</"
"literal>), or both. It matches any single character contained in the list. "
"For example, <literal>[A-Za-z]</literal> will match all letters, while "
"<literal>[0123456789]</literal> will match all numbers."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:362
msgid "Shell Commands"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:364
msgid ""
"<quote>Is not that nice,</quote> you say to yourself, <quote>but how are "
"files actually ``re-created'', as he likes to spell it?</quote> The re-"
"creation is accomplished by commands you place in the makefile. These "
"commands are passed to the Bourne shell (better known as <filename>/bin/sh</"
"filename>) to be executed and are expected to do what is necessary to update "
"the target file (<application>PMake</application> does not actually check to "
"see if the target was created. It just assumes it is there)."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:374
msgid ""
"Shell commands in a makefile look a lot like shell commands you would type "
"at a terminal, with one important exception: each command in a makefile must "
"be preceded by at least one tab."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:379
msgid ""
"Each target has associated with it a shell script made up of one or more of "
"these shell commands. The creation script for a target should immediately "
"follow the dependency line for that target. While any given target may "
"appear on more than one dependency line, only one of these dependency lines "
"may be followed by a creation script, unless the <literal>::</literal> "
"operator was used on the dependency line."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:387
msgid ""
"If the double-colon was used, each dependency line for the target may be "
"followed by a shell script. That script will only be executed if the target "
"on the associated dependency line is out-of-date with respect to the sources "
"on that line, according to the rules I gave earlier. I'll give you a good "
"example of this later on."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:394
msgid "To expand on the earlier makefile, you might add commands as follows:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:397
#, no-wrap
msgid ""
"program         : a.o b.o c.o\n"
"        cc a.o b.o c.o -o program\n"
"\n"
"a.o b.o c.o     : defs.h\n"
"a.o             : a.c\n"
"       cc -c a.c\n"
"\n"
"b.o             : b.c\n"
"       cc -c b.c\n"
"\n"
"c.o             : c.c\n"
"       cc -c c.c"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:410
msgid ""
"Something you should remember when writing a makefile is, the commands will "
"be executed if the target on the dependency line is out-of-date, not the "
"sources. In this example, the command <command>cc -c a.c</command> will be "
"executed if <filename>a.o</filename> is out-of-date. Because of the "
"<literal>:</literal> operator, this means that should <filename>a.c</"
"filename> or <filename>defs.h</filename> have been modified more recently "
"than <filename>a.o</filename>, the command will be executed (<filename>a.o</"
"filename> will be considered out-of-date)."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:421
msgid ""
"Remember how I said the only difference between a makefile shell command and "
"a regular shell command was the leading tab? I lied. There is another way in "
"which makefile commands differ from regular ones. The first two characters "
"after the initial whitespace are treated specially. If they are any "
"combination of <filename>@</filename> and <literal>-</literal>, they cause "
"<application>PMake</application> to do different things."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:429
msgid ""
"In most cases, shell commands are printed before they are actually executed. "
"This is to keep you informed of what is going on. If an <literal>@</literal> "
"appears, however, this echoing is suppressed. In the case of an echo "
"command, say"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:435
#, no-wrap
msgid "echo Linking index"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:437
msgid "it would be rather silly to see"
msgstr ""

#. (itstool) path: section/screen
#: book.translate.xml:439
#, no-wrap
msgid "echo Linking index\n"
"Linking index"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:442
msgid ""
"so <application>PMake</application> allows you to place an <literal>@</"
"literal> before the command to prevent the command from being printed:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:446
#, no-wrap
msgid "@echo Linking index"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:448
msgid ""
"The other special character is the <literal>-</literal>. In case you did not "
"know, shell commands finish with a certain <quote>exit status</quote>. This "
"status is made available by the operating system to whatever program invoked "
"the command. Normally this status will be <literal>0</literal> if everything "
"went ok and non-zero if something went wrong. For this reason, "
"<application>PMake</application> will consider an error to have occurred if "
"one of the shells it invokes returns a non-zero status. When it detects an "
"error, <application>PMake</application>'s usual action is to abort whatever "
"it is doing and exit with a non-zero status itself (any other targets that "
"were being created will continue being made, but nothing new will be started."
" <application>PMake</application> will exit after the last job finishes). "
"This behavior can be altered, however, by placing a <literal>-</literal> at "
"the front of a command (e.g. <command>-mv index index.old</command>), "
"certain command-line arguments, or doing other things, to be detailed later. "
"In such a case, the non-zero status is simply ignored and "
"<application>PMake</application> keeps chugging along."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:470
msgid ""
"Because all the commands are given to a single shell to execute, such things "
"as setting shell variables, changing directories, etc., last beyond the "
"command in which they are found. This also allows shell compound commands "
"(like for loops) to be entered in a natural manner. Since this could cause "
"problems for some makefiles that depend on each command being executed by a "
"single shell, <application>PMake</application> has a <option>-B</option> "
"flag (it stands for backwards-compatible) that forces each command to be "
"given to a separate shell. It also does several other things, all of which I "
"discourage since they are now old-fashioned."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:483
msgid ""
"A target's shell script is fed to the shell on its (the shell's) input "
"stream. This means that any commands, such as <application>ci</application> "
"that need to get input from the terminal will not work right – they will get "
"the shell's input, something they probably will not find to their liking. A "
"simple way around this is to give a command like this:"
msgstr ""

#. (itstool) path: section/screen
#: book.translate.xml:490
#, no-wrap
msgid "<command>ci $(SRCS) &lt; /dev/tty</command>"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:492
msgid ""
"This would force the program's input to come from the terminal. If you "
"cannot do this for some reason, your only other alternative is to use "
"<application>PMake</application> in its fullest compatibility mode. See "
"<quote>Compatibility</quote> in <xref linkend=\"gods\"/>."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:501
msgid "Variables"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:503
msgid ""
"<application>PMake</application>, like <application>Make</application> "
"before it, has the ability to save text in variables to be recalled later at "
"your convenience. Variables in <application>PMake</application> are used "
"much like variables in the shell and, by tradition, consist of all upper-"
"case letters (you do not have to use all upper-case letters. In fact there "
"is nothing to stop you from calling a variable <literal>@^&amp;$%$</literal>."
" Just tradition). Variables are assigned-to using lines of the form:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:513
#, no-wrap
msgid "VARIABLE = value"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:515
msgid "appended-to by:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:517
#, no-wrap
msgid "VARIABLE += value"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:519
msgid "conditionally assigned-to (if the variable is not already defined) by:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:522
#, no-wrap
msgid "VARIABLE ?= value"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:524
msgid ""
"and assigned-to with expansion (i.e. the value is expanded (see below) "
"before being assigned to the variable—useful for placing a value at the "
"beginning of a variable, or other things) by:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:529
#, no-wrap
msgid "VARIABLE := value"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:531
msgid ""
"Any whitespace before value is stripped off. When appending, a space is "
"placed between the old value and the stuff being appended."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:535
msgid "The final way a variable may be assigned to is using:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:537
#, no-wrap
msgid "VARIABLE != shell-command"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:539
msgid ""
"In this case, shell-command has all its variables expanded (see below) and "
"is passed off to a shell to execute. The output of the shell is then placed "
"in the variable. Any newlines (other than the final one) are replaced by "
"spaces before the assignment is made. This is typically used to find the "
"current directory via a line like:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:546
#, no-wrap
msgid "CWD             != pwd"
msgstr ""

#. (itstool) path: note/para
#: book.translate.xml:549
msgid ""
"This is intended to be used to execute commands that produce small amounts "
"of output (e.g. <application>pwd</application>). The implementation is less "
"than intelligent and will likely freeze if you execute something that "
"produces thousands of bytes of output (8 Kb is the limit on many <trademark "
"class=\"registered\">UNIX</trademark> systems). The value of a variable may "
"be retrieved by enclosing the variable name in parentheses or curly braces "
"and preceding the whole thing with a dollar sign."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:560
msgid ""
"For example, to set the variable <envar>CFLAGS</envar> to the string "
"<literal>-I/sprite/src/lib/libc -O,</literal> you would place a line:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:564
#, no-wrap
msgid "CFLAGS = -I/sprite/src/lib/libc -O"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:566
msgid ""
"in the makefile and use the word <literal>$(CFLAGS)</literal> wherever you "
"would like the string <literal>-I/sprite/src/lib/libc -O</literal> to appear."
" This is called variable expansion."
msgstr ""

#. (itstool) path: note/para
#: book.translate.xml:572
msgid ""
"Unlike <application>Make</application>, <application>PMake</application> "
"will not expand a variable unless it knows the variable exists. E.g. if you "
"have a <literal>${i}</literal> in a shell command and you have not assigned "
"a value to the variable <varname>i</varname> (the empty string is considered "
"a value, by the way), where <application>Make</application> would have "
"substituted the empty string, <application>PMake</application> will leave "
"the <literal>${i}</literal> alone. To keep <application>PMake</application> "
"from substituting for a variable it knows, precede the dollar sign with "
"another dollar sign (e.g. to pass <literal>${HOME}</literal> to the shell, "
"use <literal>$${HOME}</literal>). This causes <application>PMake</"
"application>, in effect, to expand the <literal>$</literal> macro, which "
"expands to a single <literal>$</literal>."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:590
msgid ""
"For compatibility, <application>Make</application>'s style of variable "
"expansion will be used if you invoke <application>PMake</application> with "
"any of the compatibility flags (<option>-V</option>, <option>-B</option> or "
"<option>-M</option>. The <option>-V</option> flag alters just the variable "
"expansion). There are two different times at which variable expansion occurs:"
" when parsing a dependency line, the expansion occurs immediately upon "
"reading the line. If any variable used on a dependency line is undefined, "
"<application>PMake</application> will print a message and exit. Variables in "
"shell commands are expanded when the command is executed. Variables used "
"inside another variable are expanded whenever the outer variable is expanded "
"(the expansion of an inner variable has no effect on the outer variable. For "
"example, if the outer variable is used on a dependency line and in a shell "
"command, and the inner variable changes value between when the dependency "
"line is read and the shell command is executed, two different values will be "
"substituted for the outer variable)."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:610
msgid ""
"Variables come in four flavors, though they are all expanded the same and "
"all look about the same. They are (in order of expanding scope):"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:616
msgid "Local variables."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:620
msgid "Command-line variables."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:624
msgid "Global variables."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:628
msgid "Environment variables."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:632
msgid ""
"The classification of variables does not matter much, except that the "
"classes are searched from the top (local) to the bottom (environment) when "
"looking up a variable. The first one found wins."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:638
msgid "Local Variables"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:640
msgid ""
"Each target can have as many as seven local variables. These are variables "
"that are only <quote>visible</quote> within that target's shell script and "
"contain such things as the target's name, all of its sources (from all its "
"dependency lines), those sources that were out-of-date, etc. Four local "
"variables are defined for all targets. They are:"
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:649
msgid "<varname>.TARGET</varname>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:652
msgid "The name of the target."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:657
msgid "<varname>.OODATE</varname>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:660
msgid ""
"The list of the sources for the target that were considered out-of-date. The "
"order in the list is not guaranteed to be the same as the order in which the "
"dependencies were given."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:668
msgid "<varname>.ALLSRC</varname>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:671
msgid ""
"The list of all sources for this target in the order in which they were "
"given."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:677
msgid "<varname>.PREFIX</varname>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:680
msgid ""
"The target without its suffix and without any leading path. E.g. for the "
"target <filename>../../lib/compat/fsRead.c</filename>, this variable would "
"contain <literal>fsRead</literal>."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:688
msgid ""
"Three other local variables are set only for certain targets under special "
"circumstances. These are the <varname>.IMPSRC,</varname> <varname>.ARCHIVE,</"
"varname> and <varname>.MEMBER</varname> variables. When they are set and how "
"they are used is described later."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:694
msgid ""
"Four of these variables may be used in sources as well as in shell scripts. "
"These are <varname>.TARGET</varname>, <varname>.PREFIX</varname>, <varname>."
"ARCHIVE</varname> and <varname>.MEMBER</varname>. The variables in the "
"sources are expanded once for each target on the dependency line, providing "
"what is known as a <quote>dynamic source,</quote> allowing you to specify "
"several dependency lines at once. For example:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:703
#, no-wrap
msgid "$(OBJS)         : $(.PREFIX).c"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:705
msgid ""
"will create a dependency between each object file and its corresponding C "
"source file."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:710
msgid "Command-line Variables"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:712
msgid ""
"Command-line variables are set when <application>PMake</application> is "
"first invoked by giving a variable assignment as one of the arguments. For "
"example:"
msgstr ""

#. (itstool) path: section/screen
#: book.translate.xml:717
#, no-wrap
msgid "pmake \"CFLAGS = -I/sprite/src/lib/libc -O\""
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:719
msgid ""
"would make <envar>CFLAGS</envar> be a command-line variable with the given "
"value. Any assignments to <envar>CFLAGS</envar> in the makefile will have no "
"effect, because once it is set, there is (almost) nothing you can do to "
"change a command-line variable (the search order, you see). Command-line "
"variables may be set using any of the four assignment operators, though only "
"<literal>=</literal> and <literal>?=</literal> behave as you would expect "
"them to, mostly because assignments to command-line variables are performed "
"before the makefile is read, thus the values set in the makefile are "
"unavailable at the time. <literal>+=</literal> is the same as <literal>=</"
"literal>, because the old value of the variable is sought only in the scope "
"in which the assignment is taking place (for reasons of efficiency that I "
"will not get into here). <literal>:=</literal> and <literal>?=</literal> "
"will work if the only variables used are in the environment. <literal>!=</"
"literal> is sort of pointless to use from the command line, since the same "
"effect can no doubt be accomplished using the shell's own command "
"substitution mechanisms (backquotes and all that)."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:742
msgid "Global Variables"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:744
msgid ""
"Global variables are those set or appended-to in the makefile. There are two "
"classes of global variables: those you set and those <application>PMake</"
"application> sets. As I said before, the ones you set can have any name you "
"want them to have, except they may not contain a colon or an exclamation "
"point. The variables <application>PMake</application> sets (almost) always "
"begin with a period and always contain upper-case letters, only. The "
"variables are as follows:"
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:756
msgid "<varname>.PMAKE</varname>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:759
msgid ""
"The name by which <application>PMake</application> was invoked is stored in "
"this variable. For compatibility, the name is also stored in the "
"<varname>MAKE</varname> variable."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:767
msgid "<varname>.MAKEFLAGS</varname>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:770
msgid ""
"All the relevant flags with which <application>PMake</application> was "
"invoked. This does not include such things as <option>-f</option> or "
"variable assignments. Again for compatibility, this value is stored in the "
"<varname>MFLAGS</varname> variable as well."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:780
msgid ""
"Two other variables, <varname>.INCLUDES</varname> and <varname>.LIBS,</"
"varname> are covered in the section on special targets in <xref linkend="
"\"shortcuts\"/>."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:784
msgid "Global variables may be deleted using lines of the form:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:787
#, no-wrap
msgid "#undef variable"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:789
msgid ""
"The <literal>#</literal> must be the first character on the line. Note that "
"this may only be done on global variables."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:795
msgid "Environment Variables"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:797
msgid ""
"Environment variables are passed by the shell that invoked "
"<application>PMake</application> and are given by <application>PMake</"
"application> to each shell it invokes. They are expanded like any other "
"variable, but they cannot be altered in any way."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:803
msgid ""
"One special environment variable, <envar>PMAKE</envar>, is examined by "
"<application>PMake</application> for command-line flags, variable "
"assignments, etc., it should always use. This variable is examined before "
"the actual arguments to <application>PMake</application> are. In addition, "
"all flags given to <application>PMake</application>, either through the "
"<envar>PMAKE</envar> variable or on the command line, are placed in this "
"environment variable and exported to each shell <application>PMake</"
"application> executes. Thus recursive invocations of <application>PMake</"
"application> automatically receive the same flags as the top-most one."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:815
msgid ""
"Using all these variables, you can compress the sample makefile even more:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:818
#, no-wrap
msgid ""
"OBJS            = a.o b.o c.o\n"
"\n"
"program         : $(OBJS)\n"
"        cc $(.ALLSRC) -o $(.TARGET)\n"
"\n"
"$(OBJS)         : defs.h\n"
"\n"
"a.o             : a.c\n"
"        cc -c a.c\n"
"\n"
"b.o             : b.c\n"
"        cc -c b.c\n"
"\n"
"c.o             : c.c\n"
"        cc -c c.c"
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:837
msgid "Comments"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:839
msgid ""
"Comments in a makefile start with a <literal>#</literal> character and "
"extend to the end of the line. They may appear anywhere you want them, "
"except in a shell command (though the shell will treat it as a comment, too)."
" If, for some reason, you need to use the <literal>#</literal> in a variable "
"or on a dependency line, put a backslash in front of it. <application>PMake</"
"application> will compress the two into a single <literal>#</literal>."
msgstr ""

#. (itstool) path: note/para
#: book.translate.xml:849
msgid ""
"This is not true if <application>PMake</application> is operating in full-"
"compatibility mode)."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:855
msgid "Parallelism"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:857
msgid ""
"<application>PMake</application> was specifically designed to re-create "
"several targets at once, when possible. You do not have to do anything "
"special to cause this to happen (unless <application>PMake</application> was "
"configured to not act in parallel, in which case you will have to make use "
"of the <option>-L</option> and <option>-J</option> flags (see below)), but "
"you do have to be careful at times."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:865
msgid ""
"There are several problems you are likely to encounter. One is that some "
"makefiles (and programs) are written in such a way that it is impossible for "
"two targets to be made at once. The program <application>xstr</application>, "
"for example, always modifies the files <filename>strings</filename> and "
"<filename>x.c</filename>. There is no way to change it. Thus you cannot run "
"two of them at once without something being trashed. Similarly, if you have "
"commands in the makefile that always send output to the same file, you will "
"not be able to make more than one target at once unless you change the file "
"you use. You can, for instance, add a <literal>$$$$</literal> to the end of "
"the file name to tack on the process ID of the shell executing the command "
"(each <literal>$$</literal> expands to a single <literal>$</literal>, thus "
"giving you the shell variable <literal>$$</literal>). Since only one shell "
"is used for all the commands, you will get the same file name for each "
"command in the script."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:883
msgid ""
"The other problem comes from improperly-specified dependencies that worked "
"in <application>Make</application> because of its sequential, depth-first "
"way of examining them. While I do not want to go into depth on how "
"<application>PMake</application> works (look in <xref linkend=\"gods\"/> if "
"you are interested), I will warn you that files in two different levels of "
"the dependency tree may be examined in a different order in "
"<application>PMake</application> than they were in <application>Make</"
"application>. For example, given the makefile:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:894
#, no-wrap
msgid "a               :\n"
"\n"
"b c b           : d"
msgstr ""

#. (itstool) path: para/buildtarget
#: book.translate.xml:899 book.translate.xml:903 book.translate.xml:905
#: book.translate.xml:908 book.translate.xml:1101
msgid "c"
msgstr ""

#. (itstool) path: para/buildtarget
#: book.translate.xml:900 book.translate.xml:1103
msgid "d"
msgstr ""

#. (itstool) path: para/buildtarget
#: book.translate.xml:900 book.translate.xml:904 book.translate.xml:909
#: book.translate.xml:1105
msgid "b"
msgstr ""

#. (itstool) path: para/buildtarget
#: book.translate.xml:901 book.translate.xml:1103
msgid "a"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:898
msgid ""
"<application>PMake</application> will examine the targets in the order <_:"
"buildtarget-1/>, <_:buildtarget-2/>, <_:buildtarget-3/>, <_:buildtarget-4/>. "
"If the makefile's author expected <application>PMake</application> to abort "
"before making <_:buildtarget-5/> if an error occurred while making <_:"
"buildtarget-6/>, or if <_:buildtarget-7/> needed to exist before <_:"
"buildtarget-8/> was made, (s)he will be sorely disappointed. The "
"dependencies are incomplete, since in both these cases, <_:buildtarget-9/> "
"would depend on <_:buildtarget-10/>. So watch out."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:911
msgid ""
"Another problem you may face is that, while <application>PMake</application> "
"is set up to handle the output from multiple jobs in a graceful fashion, the "
"same is not so for input. It has no way to regulate input to different jobs, "
"so if you use the redirection from <filename>/dev/tty</filename> I mentioned "
"earlier, you must be careful not to run two of the jobs at once."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:921
msgid "Writing and Debugging a Makefile"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:923
msgid ""
"Now you know most of what is in a <filename>Makefile</filename>, what do you "
"do next? There are two choices: use one of the uncommonly-available makefile "
"generators or write your own makefile (I leave out the third choice of "
"ignoring <application>PMake</application> and doing everything by hand as "
"being beyond the bounds of common sense)."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:931
msgid ""
"When faced with the writing of a makefile, it is usually best to start from "
"first principles: just what are you trying to do? What do you want the "
"makefile finally to produce? To begin with a somewhat traditional example, "
"let's say you need to write a makefile to create a program, <command>expr</"
"command>, that takes standard infix expressions and converts them to prefix "
"form (for no readily apparent reason). You have got three source files, in "
"C, that make up the program: <filename>main.c</filename>, <filename>parse.c</"
"filename>, and <filename>output.c</filename>. Harking back to my pithy "
"advice about dependency lines, you write the first line of the file:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:944
#, no-wrap
msgid "expr            : main.o parse.o output.o"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:946
msgid ""
"because you remember <filename>expr</filename> is made from <filename>.o</"
"filename> files, not <filename>.c</filename> files. Similarly for the "
"<filename>.o</filename> files you produce the lines:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:951
#, no-wrap
msgid ""
"main.o          : main.c\n"
"\n"
"parse.o         : parse.c\n"
"\n"
"output.o        : output.c\n"
"\n"
"main.o parse.o output.o : defs.h"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:959
msgid ""
"Great. You have now got the dependencies specified. What you need now is "
"commands. These commands, remember, must produce the target on the "
"dependency line, usually by using the sources you have listed. You remember "
"about local variables? Good, so it should come to you as no surprise when "
"you write:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:966
#, no-wrap
msgid "expr            : main.o parse.o output.o\n"
"\tcc -o $(.TARGET) $(.ALLSRC)"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:969
msgid ""
"Why use the variables? If your program grows to produce postfix expressions "
"too (which, of course, requires a name change or two), it is one fewer place "
"you have to change the file. You cannot do this for the object files, "
"however, because they depend on their corresponding source files and "
"<filename>defs.h</filename>, thus if you said:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:976
#, no-wrap
msgid "cc -c $(.ALLSRC)"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:978
msgid "you will get (for <filename>main.o</filename>):"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:980
#, no-wrap
msgid "cc -c main.c defs.h"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:982
msgid "which is wrong. So you round out the makefile with these lines:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:985
#, no-wrap
msgid ""
"main.o          : main.c\n"
"\tcc -c main.c\n"
"\n"
"parse.o         : parse.c\n"
"\tcc -c parse.c\n"
"\n"
"output.o        : output.c\n"
"\tcc -c output.c"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:994
msgid ""
"The makefile is now complete and will, in fact, create the program you want "
"it to without unnecessary compilations or excessive typing on your part. "
"There are two things wrong with it, however (aside from it being altogether "
"too long, something I will address in <xref linkend=\"shortcuts\"/>):"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1002
msgid ""
"The string <literal>main.o parse.o output.o</literal> is repeated twice, "
"necessitating two changes when you add postfix (you were planning on that, "
"were not you?). This is in direct violation of de Boor's First Rule of "
"writing makefiles:"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1008
msgid ""
"Anything that needs to be written more than once should be placed in a "
"variable. I cannot emphasize this enough as being very important to the "
"maintenance of a makefile and its program."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1015
msgid ""
"There is no way to alter the way compilations are performed short of editing "
"the makefile and making the change in all places. This is evil and violates "
"de Boor's Second Rule, which follows directly from the first:"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1020
msgid ""
"Any flags or programs used inside a makefile should be placed in a variable "
"so they may be changed, temporarily or permanently, with the greatest ease."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1026
msgid "The makefile should more properly read:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:1028
#, no-wrap
msgid ""
"OBJS            = main.o parse.o output.o\n"
"\n"
"expr            : $(OBJS)\n"
"\t$(CC) $(CFLAGS) -o $(.TARGET) $(.ALLSRC)\n"
"\n"
"main.o          : main.c\n"
"\t$(CC) $(CFLAGS) -c main.c\n"
"\n"
"parse.o         : parse.c\n"
"\t$(CC) $(CFLAGS) -c parse.c\n"
"\n"
"output.o        : output.c\n"
"\t$(CC) $(CFLAGS) -c output.c\n"
"\n"
"$(OBJS)         : defs.h"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1044
msgid ""
"Alternatively, if you like the idea of dynamic sources mentioned in <xref "
"linkend=\"localvariables\"/>, you could write it like this:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:1048
#, no-wrap
msgid ""
"OBJS            = main.o parse.o output.o\n"
"\n"
"expr            : $(OBJS)\n"
"\t$(CC) $(CFLAGS) -o $(.TARGET) $(.ALLSRC)\n"
"\n"
"$(OBJS)         : $(.PREFIX).c defs.h\n"
"\t$(CC) $(CFLAGS) -c $(.PREFIX).c"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1056
msgid ""
"These two rules and examples lead to de Boor's First Corollary: "
"<emphasis>Variables are your friends</emphasis>."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1060
msgid ""
"Once you have written the makefile comes the sometimes-difficult task of "
"making sure the darn thing works. Your most helpful tool to make sure the "
"makefile is at least syntactically correct is the <option>-n</option> flag, "
"which allows you to see if <application>PMake</application> will choke on "
"the makefile. The second thing the <option>-n</option> flag lets you do is "
"see what <application>PMake</application> would do without it actually doing "
"it, thus you can make sure the right commands would be executed were you to "
"give <application>PMake</application> its head."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1071
msgid ""
"When you find your makefile is not behaving as you hoped, the first question "
"that comes to mind (after <quote>What time is it, anyway?</quote>) is "
"<quote>Why not?</quote> In answering this, two flags will serve you well: "
"<literal>-d m</literal> and <quote>-p 2</quote>. The first causes "
"<application>PMake</application> to tell you as it examines each target in "
"the makefile and indicate why it is deciding whatever it is deciding. You "
"can then use the information printed for other targets to see where you went "
"wrong. The <quote>-p 2</quote> flag makes <application>PMake</application> "
"print out its internal state when it is done, allowing you to see that you "
"forgot to make that one chapter depend on that file of macros you just got a "
"new version of. The output from <quote>-p 2</quote> is intended to resemble "
"closely a real makefile, but with additional information provided and with "
"variables expanded in those commands <application>PMake</application> "
"actually printed or executed."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1090
msgid ""
"Something to be especially careful about is circular dependencies. For "
"example:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:1093
#, no-wrap
msgid "a         : b\n"
"\n"
"b         : c d\n"
"\n"
"d         : a"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1099
msgid ""
"In this case, because of how <application>PMake</application> works, <_:"
"buildtarget-1/> is the only thing <application>PMake</application> will "
"examine, because <_:buildtarget-2/> and <_:buildtarget-3/> will effectively "
"fall off the edge of the universe, making it impossible to examine <_:"
"buildtarget-4/> (or them, for that matter). <application>PMake</application> "
"will tell you (if run in its normal mode) all the targets involved in any "
"cycle it looked at (i.e. if you have two cycles in the graph (naughty, "
"naughty), but only try to make a target in one of them, <application>PMake</"
"application> will only tell you about that one. You will have to try to make "
"the other to find the second cycle). When run as <application>Make</"
"application>, it will only print the first target in the cycle."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:1117
msgid "Invoking PMake"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1119
msgid ""
"<application>PMake</application> comes with a wide variety of flags to "
"choose from. They may appear in any order, interspersed with command-line "
"variable assignments and targets to create. The flags are as follows:"
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1126
msgid "<option>-d <replaceable>what</replaceable></option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1129
msgid ""
"This causes <application>PMake</application> to spew out debugging "
"information that may prove useful to you. If you cannot figure out why "
"<application>PMake</application> is doing what it is doing, you might try "
"using this flag. The <replaceable>what</replaceable> parameter is a string "
"of single characters that tell <application>PMake</application> what aspects "
"you are interested in. Most of what I describe will make little sense to "
"you, unless you have dealt with <application>Make</application> before. Just "
"remember where this table is and come back to it as you read on. The "
"characters and the information they produce are as follows:"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1148
msgid "<literal>a</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1150
msgid "Archive searching and caching."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1154
msgid "<literal>c</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1156
msgid "Conditional evaluation."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1160
msgid "<literal>d</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1162
msgid "The searching and caching of directories."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1167
msgid "<literal>j</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1169
msgid ""
"Various snippets of information related to the running of the multiple "
"shells. Not particularly interesting."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1175
msgid "<literal>m</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1177
msgid ""
"The making of each target: what target is being examined; when it was last "
"modified; whether it is out-of-date; etc."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1183
msgid "<literal>p</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1185
msgid "Makefile parsing."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1189
msgid "<literal>r</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1191
msgid "Remote execution."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1195
msgid "<literal>s</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1197
msgid ""
"The application of suffix-transformation rules. (See <xref linkend="
"\"shortcuts\"/>.)"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1202
msgid "<literal>t</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1204
msgid "The maintenance of the list of targets."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1208
msgid "<literal>v</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:1210
msgid "Variable assignment."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1216
msgid ""
"Of these all, the <literal>m</literal> and <literal>s</literal> letters will "
"be most useful to you. If the <option>-d</option> is the final argument or "
"the argument from which it would get these key letters (see below for a note "
"about which argument would be used) begins with a –, all of these debugging "
"flags will be set, resulting in massive amounts of output."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1227
msgid "<option>-f</option> makefile"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1230
msgid ""
"Specify a makefile to read different from the standard makefiles "
"(<filename>Makefile</filename> or <filename>makefile</filename>). If "
"makefile is <literal>-</literal>, <application>PMake</application> uses the "
"standard input. This is useful for making quick and dirty makefiles."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1240
msgid "<option>-h</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1243
msgid ""
"Prints out a summary of the various flags <application>PMake</application> "
"accepts. It can also be used to find out what level of concurrency was "
"compiled into the version of <application>PMake</application> you are using "
"(look at <literal>-J</literal> and <literal>-L</literal>) and various other "
"information on how <application>PMake</application> was configured."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1254
msgid "<option>-i</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1257
msgid ""
"If you give this flag, <application>PMake</application> will ignore non-zero "
"status returned by any of its shells. It is like placing a <literal>-</"
"literal> before all the commands in the makefile."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1265
msgid "<option>-k</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1268
msgid ""
"This is similar to <option>-i</option> in that it allows <application>PMake</"
"application> to continue when it sees an error, but unlike <option>-i</"
"option>, where <application>PMake</application> continues blithely as if "
"nothing went wrong, <option>-k</option> causes it to recognize the error and "
"only continue work on those things that do not depend on the target, either "
"directly or indirectly (through depending on something that depends on it), "
"whose creation returned the error. The <option>k</option> is for <quote>keep "
"going</quote>."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1281
msgid "<option>-l</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1284
msgid ""
"<application>PMake</application> has the ability to lock a directory against "
"other people executing it in the same directory (by means of a file called "
"<filename>LOCK.make</filename> that it creates and checks for in the "
"directory). This is a Good Thing because two people doing the same thing in "
"the same place can be disastrous for the final product (too many cooks and "
"all that). Whether this locking is the default is up to your system "
"administrator. If locking is on, <option>-l</option> will turn it off, and "
"vice versa. Note that this locking will not prevent you from invoking "
"<application>PMake</application> twice in the same place–if you own the lock "
"file, <application>PMake</application> will warn you about it but continue "
"to execute."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1301
msgid "<option>-m <replaceable>directory</replaceable></option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1304
msgid ""
"Tells <application>PMake</application> another place to search for included "
"makefiles via the &lt;<replaceable>filename</replaceable>&gt; style. Several "
"<filename>-m</filename> options can be given to form a search path. If this "
"construct is used the default system makefile search path is completely "
"overridden."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1314
msgid "<option>-n</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1317
msgid ""
"This flag tells <application>PMake</application> not to execute the commands "
"needed to update the out-of-date targets in the makefile. Rather, "
"<application>PMake</application> will simply print the commands it would "
"have executed and exit. This is particularly useful for checking the "
"correctness of a makefile. If <application>PMake</application> does not do "
"what you expect it to, it is a good chance the makefile is wrong."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1328
msgid "<option>-p number</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1331
msgid ""
"This causes <application>PMake</application> to print its input in a "
"reasonable form, though not necessarily one that would make immediate sense "
"to anyone but me. The number is a bitwise OR of 1 and 2, where 1 means it "
"should print the input before doing any processing and 2 says it should "
"print it after everything has been re-created. Thus <option>-p 3</option> "
"would print it twice-a-once before processing and once after (you might find "
"the difference between the two interesting). This is mostly useful to me, "
"but you may find it informative in some bizarre circumstances."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1345
msgid "<option>-q</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1348
msgid ""
"If you give <application>PMake</application> this flag, it will not try to "
"re-create anything. It will just see if anything is out-of-date and exit non-"
"zero if so."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1355
msgid "<option>-r</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1358
msgid ""
"When <application>PMake</application> starts up, it reads a default makefile "
"that tells it what sort of system it is on and gives it some idea of what to "
"do if you do not tell it anything. I will tell you about it in <xref linkend="
"\"shortcuts\"/>. If you give this flag, <application>PMake</application> "
"will not read the default makefile."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1368
msgid "<option>-s</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1371
msgid ""
"This causes <application>PMake</application> to not print commands before "
"they are executed. It is the equivalent of putting an <quote>@</quote> "
"before every command in the makefile."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1379
msgid "<option>-t</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1382
msgid ""
"Rather than try to re-create a target, <application>PMake</application> will "
"simply <quote>touch</quote> it so as to make it appear up-to-date. If the "
"target did not exist before, it will when <application>PMake</application> "
"finishes, but if the target did exist, it will appear to have been updated."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1392
msgid "<option>-v</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1395
msgid ""
"Targets can still be created in parallel, however. This is the mode "
"<application>PMake</application> will enter if it is invoked either as "
"<command>smake</command> or <command>vmake</command>."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1403
msgid "<option>-x</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1406
msgid ""
"This tells <application>PMake</application> it is OK to export jobs to other "
"machines, if they are available. It is used when running in Make mode, as "
"exporting in this mode tends to make things run slower than if the commands "
"were just executed locally."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1415
msgid "<option>-B</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1418
msgid ""
"Forces <application>PMake</application> to be as backwards-compatible with "
"<application>Make</application> as possible while still being itself. This "
"includes:"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1424
msgid "Executing one shell per shell command"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1428
msgid ""
"Expanding anything that looks even vaguely like a variable, with the empty "
"string replacing any variable <application>PMake</application> does not know."
""
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1434
msgid ""
"Refusing to allow you to escape a <literal>#</literal> with a backslash."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1439
msgid ""
"Permitting undefined variables on dependency lines and conditionals (see "
"below). Normally this causes <application>PMake</application> to abort."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1448
msgid "<option>-C</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1451
msgid ""
"This nullifies any and all compatibility mode flags you may have given or "
"implied up to the time the <option>-C</option> is encountered. It is useful "
"mostly in a makefile that you wrote for <application>PMake</application> to "
"avoid bad things happening when someone runs <application>PMake</"
"application> as <application>make</application> or has things set in the "
"environment that tell it to be compatible. <option>-C</option> is not placed "
"in the <envar>PMAKE</envar> environment variable or the <varname>.MAKEFLAGS</"
"varname> or <envar>MFLAGS</envar> global variables."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1465
msgid "<option>-D <replaceable>variable</replaceable></option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1468
msgid ""
"Allows you to define a variable to have <quote>1</quote> as its value. The "
"variable is a global variable, not a command-line variable. This is useful "
"mostly for people who are used to the C compiler arguments and those using "
"conditionals, which I will get into in <xref linkend=\"condition\"/>."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1477
msgid "<option>-I <replaceable>directory</replaceable></option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1480
msgid ""
"Tells <application>PMake</application> another place to search for included "
"makefiles. Yet another thing to be explained in <xref linkend=\"shortcuts\"/"
"> (<xref linkend=\"including\"/>, to be precise)."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1488
msgid "<option>-J <replaceable>number</replaceable></option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1491
msgid ""
"Gives the absolute maximum number of targets to create at once on both local "
"and remote machines."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1497
msgid "<option>-L <replaceable>number</replaceable></option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1500
msgid ""
"This specifies the maximum number of targets to create on the local machine "
"at once. This may be <literal>0</literal>, though you should be wary of "
"doing this, as <application>PMake</application> may hang until a remote "
"machine becomes available, if one is not available when it is started."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1510
msgid "<option>-M</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1513
msgid ""
"This is the flag that provides absolute, complete, full compatibility with "
"<application>Make</application>. It still allows you to use all but a few of "
"the features of <application>PMake</application>, but it is non-parallel. "
"This is the mode <application>PMake</application> enters if you call it "
"<command>make</command>."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1523
msgid "<option>-P</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1526
msgid ""
"When creating targets in parallel, several shells are executing at once, "
"each wanting to write its own two cents'-worth to the screen. This output "
"must be captured by <application>PMake</application> in some way in order to "
"prevent the screen from being filled with garbage even more indecipherable "
"than you usually see. <application>PMake</application> has two ways of doing "
"this, one of which provides for much cleaner output and a clear separation "
"between the output of different jobs, the other of which provides a more "
"immediate response so one can tell what is really happening. The former is "
"done by notifying you when the creation of a target starts, capturing the "
"output and transferring it to the screen all at once when the job finishes. "
"The latter is done by catching the output of the shell (and its children) "
"and buffering it until an entire line is received, then printing that line "
"preceded by an indication of which job produced the output. Since I prefer "
"this second method, it is the one used by default. The first method will be "
"used if you give the <option>-P</option> flag to <application>PMake</"
"application>."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1549
msgid "<option>-V</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1552
msgid ""
"As mentioned before, the <option>-V</option> flag tells <application>PMake</"
"application> to use <application>Make</application>'s style of expanding "
"variables, substituting the empty string for any variable it does not know."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1561
msgid "<option>-W</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1564
msgid ""
"There are several times when <application>PMake</application> will print a "
"message at you that is only a warning, i.e. it can continue to work in spite "
"of your having done something silly (such as forgotten a leading tab for a "
"shell command). Sometimes you are well aware of silly things you have done "
"and would like <application>PMake</application> to stop bothering you. This "
"flag tells it to shut up about anything non-fatal."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1575
msgid "<option>-X</option>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1578
msgid ""
"This flag causes <application>PMake</application> to not attempt to export "
"any jobs to another machine."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1584
msgid ""
"Several flags may follow a single <literal>-</literal>. Those flags that "
"require arguments take them from successive parameters. For example:"
msgstr ""

#. (itstool) path: section/screen
#: book.translate.xml:1588
#, no-wrap
msgid "pmake -fDnI server.mk DEBUG /chip2/X/server/include"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1590
msgid ""
"will cause <application>PMake</application> to read <filename>server.mk</"
"filename> as the input makefile, define the variable <varname>DEBUG</"
"varname> as a global variable and look for included makefiles in the "
"directory <filename>/chip2/X/server/include</filename>."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:1598
msgid "Summary"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1600
msgid "A makefile is made of four types of lines:"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1604
msgid "Dependency lines"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1620
msgid ""
"A dependency line is a list of one or more targets, an operator (<literal>:</"
"literal>, <literal>::</literal>, or <literal>!</literal>), and a list of "
"zero or more sources. Sources may contain wildcards and certain local "
"variables."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1625
msgid ""
"A creation command is a regular shell command preceded by a tab. In "
"addition, if the first two characters after the tab (and other whitespace) "
"are a combination of <literal>@</literal> or <literal>-</literal>, "
"<application>PMake</application> will cause the command to not be printed "
"(if the character is <literal>@</literal>) or errors from it to be ignored "
"(if <literal>-</literal>). A blank line, dependency line or variable "
"assignment terminates a creation script. There may be only one creation "
"script for each target with a <literal>:</literal> or <literal>!</literal> "
"operator."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1635
msgid ""
"Variables are places to store text. They may be unconditionally assigned-to "
"using the <literal>=</literal> operator, appended-to using the <literal>+=</"
"literal> operator, conditionally (if the variable is undefined) assigned-to "
"with the <literal>?=</literal> operator, and assigned-to with variable "
"expansion with the <literal>:=</literal> operator. The output of a shell "
"command may be assigned to a variable using the <literal>!=</literal> "
"operator. Variables may be expanded (their value inserted) by enclosing "
"their name in parentheses or curly braces, preceded by a dollar sign. A "
"dollar sign may be escaped with another dollar sign. Variables are not "
"expanded if <application>PMake</application> does not know about them. There "
"are seven local variables: <varname>.TARGET</varname>, <varname>.ALLSRC</"
"varname>, <varname>.OODATE</varname>, <varname>.PREFIX</varname>, <varname>."
"IMPSRC</varname>, <varname>.ARCHIVE</varname>, and <varname>.MEMBER</"
"varname>. Four of them (<varname>.TARGET</varname>, <varname>.PREFIX</"
"varname>, <varname>.ARCHIVE</varname>, and <varname>.MEMBER</varname>) may "
"be used to specify <quote>dynamic sources</quote>. Variables are good. Know "
"them. Love them. Live them."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1655
msgid ""
"Debugging of makefiles is best accomplished using the <option>-n</option>, "
"<option>-d m</option>, and <option>-p 2</option> flags."
msgstr ""

#. (itstool) path: chapter/title
#: book.translate.xml:1666
msgid "Short-cuts and Other Nice Things"
msgstr ""

#. (itstool) path: chapter/para
#: book.translate.xml:1668
msgid ""
"Based on what I have told you so far, you may have gotten the impression "
"that <application>PMake</application> is just a way of storing away commands "
"and making sure you do not forget to compile something. Good. That is just "
"what it is. However, the ways I have described have been inelegant, at best, "
"and painful, at worst. This chapter contains things that make the writing of "
"makefiles easier and the makefiles themselves shorter and easier to modify "
"(and, occasionally, simpler). In this chapter, I assume you are somewhat "
"more familiar with Sprite (or <trademark class=\"registered\">UNIX</"
"trademark>, if that is what you are using) than I did in <xref linkend="
"\"basics\"/>, just so you are on your toes. So without further ado…"
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:1681
msgid "Transformation Rules"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1683
msgid ""
"As you know, a file's name consists of two parts: a base name, which gives "
"some hint as to the contents of the file, and a suffix, which usually "
"indicates the format of the file. Over the years, as <trademark class="
"\"registered\">UNIX</trademark> has developed, naming conventions, with "
"regard to suffixes, have also developed that have become almost as "
"incontrovertible as Law. E.g. a file ending in <filename>.c</filename> is "
"assumed to contain C source code; one with a <filename>.o</filename> suffix "
"is assumed to be a compiled, relocatable object file that may be linked into "
"any program; a file with a <filename>.ms</filename> suffix is usually a text "
"file to be processed by <application>Troff</application> with the <literal>-"
"ms</literal> macro package, and so on. One of the best aspects of both "
"<application>Make</application> and <application>PMake</application> comes "
"from their understanding of how the suffix of a file pertains to its "
"contents and their ability to do things with a file based solely on its "
"suffix. This ability comes from something known as a transformation rule. A "
"transformation rule specifies how to change a file with one suffix into a "
"file with another suffix."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1704
msgid ""
"A transformation rule looks much like a dependency line, except the target "
"is made of two known suffixes stuck together. Suffixes are made known to "
"<application>PMake</application> by placing them as sources on a dependency "
"line whose target is the special target <varname>.SUFFIXES</varname>. E.g.:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:1711
#, no-wrap
msgid ".SUFFIXES   : .o .c\n"
".c.o        :\n"
"\t$(CC) $(CFLAGS) -c $(.IMPSRC)"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1715
msgid ""
"The creation script attached to the target is used to trans form a file with "
"the first suffix (in this case, <filename>.c</filename>) into a file with "
"the second suffix (here, <filename>.o</filename>). In addition, the target "
"inherits whatever attributes have been applied to the transformation rule. "
"The simple rule given above says that to transform a C source file into an "
"object file, you compile it using <application>cc</application> with the "
"<option>-c</option> flag. This rule is taken straight from the system "
"makefile. Many transformation rules (and suffixes) are defined there, and I "
"refer you to it for more examples (type <command>pmake -h</command> to find "
"out where it is)."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1730
msgid ""
"There are several things to note about the transformation rule given above:"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1735
msgid ""
"The <varname>.IMPSRC</varname> variable. This variable is set to the "
"<quote>implied source</quote> (the file from which the target is being "
"created; the one with the first suffix), which, in this case, is the "
"<filename>.c</filename> file."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1744
msgid ""
"The <envar>CFLAGS</envar> variable. Almost all of the transformation rules "
"in the system makefile are set up using variables that you can alter in your "
"makefile to tailor the rule to your needs. In this case, if you want all "
"your C files to be compiled with the <option>-g</option> flag, to provide "
"information for dbx, you would set the <envar>CFLAGS</envar> variable to "
"contain <option>-g</option> (<literal>CFLAGS = -g</literal>) and "
"<application>PMake</application> would take care of the rest."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1757
msgid ""
"To give you a quick example, the makefile in <xref linkend=\"envvars\"/> "
"could be changed to this:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:1760
#, no-wrap
msgid ""
"OBJS            = a.o b.o c.o\n"
"program         : $(OBJS)\n"
"\t $(CC) -o $(.TARGET) $(.ALLSRC)\n"
"$(OBJS)         : defs.h"
msgstr ""

#. (itstool) path: footnote/para
#: book.translate.xml:1768
msgid ""
"This is also somewhat cleaner, I think, than the dynamic source solution "
"presented in <xref linkend=\"writeanddebug\"/>."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1765
msgid ""
"The transformation rule I gave above takes the place of the 6 lines <_:"
"footnote-1/>:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:1773
#, no-wrap
msgid ""
"a.o             : a.c\n"
"\tcc -c a.c\n"
"b.o             : b.c\n"
"\tcc -c b.c\n"
"c.o             : c.c\n"
"\tcc -c c.c"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1780
msgid ""
"Now you may be wondering about the dependency between the <filename>.o</"
"filename> and <filename>.c</filename> files – it is not mentioned anywhere "
"in the new makefile. This is because it is not needed: one of the effects of "
"applying a transformation rule is the target comes to depend on the implied "
"source. That's why it is called the implied source."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1788
msgid "For a more detailed example. Say you have a makefile like this:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:1791
#, no-wrap
msgid "a.out           : a.o b.o\n"
"\t$(CC) $(.ALLSRC)"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1794
msgid "and a directory set up like this:"
msgstr ""

#. (itstool) path: section/screen
#: book.translate.xml:1796
#, no-wrap
msgid ""
"total 4\n"
"-rw-rw-r--  1 deboor        34 Sep  7 00:43 Makefile\n"
"-rw-rw-r--  1 deboor       119 Oct  3 19:39 a.c\n"
"-rw-rw-r--  1 deboor       201 Sep  7 00:43 a.o\n"
"-rw-rw-r--  1 deboor        69 Sep  7 00:43 b.c"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1802
msgid ""
"While just typing <command>pmake</command> will do the right thing, it is "
"much more informative to type <command>pmake -d s</command>. This will show "
"you what <application>PMake</application> is up to as it processes the files."
" In this case, <application>PMake</application> prints the following:"
msgstr ""

#. (itstool) path: section/screen
#: book.translate.xml:1809
#, no-wrap
msgid ""
"Suff_FindDeps (a.out)\n"
"     using existing source a.o\n"
"     applying .o -&gt; .out to \"a.o\"\n"
"Suff_FindDeps (a.o)\n"
"     trying a.c...got it\n"
"     applying .c -&gt; .o to \"a.c\"\n"
"Suff_FindDeps (b.o)\n"
"     trying b.c...got it\n"
"     applying .c -&gt; .o to \"b.c\"\n"
"Suff_FindDeps (a.c)\n"
"     trying a.y...not there\n"
"     trying a.l...not there\n"
"     trying a.c,v...not there\n"
"     trying a.y,v...not there\n"
"     trying a.l,v...not there\n"
"Suff_FindDeps (b.c)\n"
"     trying b.y...not there\n"
"     trying b.l...not there\n"
"     trying b.c,v...not there\n"
"     trying b.y,v...not there\n"
"     trying b.l,v...not there\n"
"--- a.o ---\n"
"cc  -c a.c\n"
"--- b.o ---\n"
"cc  -c b.c\n"
"--- a.out ---\n"
"cc a.o b.o"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1837
msgid ""
"<computeroutput>Suff_FindDeps</computeroutput> is the name of a function in "
"<application>PMake</application> that is called to check for implied sources "
"for a target using transformation rules. The transformations it tries are, "
"naturally enough, limited to the ones that have been defined (a "
"transformation may be defined multiple times, by the way, but only the most "
"recent one will be used). You will notice, however, that there is a definite "
"order to the suffixes that are tried. This order is set by the relative "
"positions of the suffixes on the <varname>.SUFFIXES</varname> line – the "
"earlier a suffix appears, the earlier it is checked as the source of a "
"transformation. Once a suffix has been defined, the only way to change its "
"position in the pecking order is to remove all the suffixes (by having a "
"<varname>.SUFFIXES</varname> dependency line with no sources) and redefine "
"them in the order you want. (Previously-defined transformation rules will be "
"automatically redefined as the suffixes they involve are re-entered.) "
"Another way to affect the search order is to make the dependency explicit. "
"In the above example, <filename>a.out</filename> depends on <filename>a.o</"
"filename> and <filename>b.o</filename>. Since a transformation exists from "
"<filename>.o</filename> to <filename>.out</filename>, <application>PMake</"
"application> uses that, as indicated by the <computeroutput>using existing "
"source a.o</computeroutput> message."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1864
msgid ""
"The search for a transformation starts from the suffix of the target and "
"continues through all the defined transformations, in the order dictated by "
"the suffix ranking, until an existing file with the same base (the target "
"name minus the suffix and any leading directories) is found. At that point, "
"one or more transformation rules will have been found to change the one "
"existing file into the target."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1872
msgid ""
"For example, ignoring what's in the system makefile for now, say you have a "
"makefile like this:"
msgstr ""

#. (itstool) path: section/screen
#: book.translate.xml:1875
#, no-wrap
msgid ""
".SUFFIXES       : .out .o .c .y .l\n"
".l.c            :\n"
"\tlex $(.IMPSRC)\n"
"\tmv lex.yy.c $(.TARGET)\n"
".y.c            :\n"
"\tyacc $(.IMPSRC)\n"
"\tmv y.tab.c $(.TARGET)\n"
".c.o            :\n"
"\tcc -c $(.IMPSRC)\n"
".o.out          :\n"
"\tcc -o $(.TARGET) $(.IMPSRC)"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1887
msgid ""
"and the single file <filename>jive.l</filename>. If you were to type "
"<command>pmake -rd ms jive.out</command>, you would get the following output "
"for <filename>jive.out</filename>:"
msgstr ""

#. (itstool) path: section/screen
#: book.translate.xml:1892
#, no-wrap
msgid ""
"Suff_FindDeps (jive.out)\n"
"     trying jive.o...not there\n"
"     trying jive.c...not there\n"
"     trying jive.y...not there\n"
"     trying jive.l...got it\n"
"     applying .l -&gt; .c to \"jive.l\"\n"
"     applying .c -&gt; .o to \"jive.c\"\n"
"     applying .o -&gt; .out to \"jive.o\""
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1901
msgid ""
"and this is why: <application>PMake</application> starts with the target "
"<filename>jive.out</filename>, figures out its suffix (<filename>.out</"
"filename>) and looks for things it can transform to a <filename>.out</"
"filename> file. In this case, it only finds <filename>.o</filename>, so it "
"looks for the file <filename>jive.o</filename>. It fails to find it, so it "
"looks for transformations into a <filename>.o</filename> file. Again it has "
"only one choice: <filename>.c</filename>. So it looks for <filename>jive.c</"
"filename> and, as you know, fails to find it. At this point it has two "
"choices: it can create the <filename>.c</filename> file from either a "
"<filename>.y</filename> file or a <filename>.l</filename> file. Since "
"<filename>.y</filename> came first on the <varname>.SUFFIXES</varname> line, "
"it checks for <filename>jive.y</filename> first, but can not find it, so it "
"looks for <filename>jive.l</filename> and, lo and behold, there it is. At "
"this point, it has defined a transformation path as follows:"
msgstr ""

#. (itstool) path: section/literallayout
#: book.translate.xml:1919
#, no-wrap
msgid ""
"<filename>.l</filename>  -&gt;  <filename>.c</filename>  -&gt;  <filename>."
"o</filename>  -&gt; <filename>.out</filename>"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1921
msgid ""
"and applies the transformation rules accordingly. For completeness, and to "
"give you a better idea of what <application>PMake</application> actually did "
"with this three-step transformation, this is what <application>PMake</"
"application> printed for the rest of the process:"
msgstr ""

#. (itstool) path: section/screen
#: book.translate.xml:1927
#, no-wrap
msgid ""
"Suff_FindDeps (jive.o)\n"
"     using existing source jive.c\n"
"     applying .c -&gt; .o to \"jive.c\"\n"
"Suff_FindDeps (jive.c)\n"
"     using existing source jive.l\n"
"     applying .l -&gt; .c to \"jive.l\"\n"
"Suff_FindDeps (jive.l)\n"
"Examining jive.l...modified 17:16:01 Oct 4, 1987...up-to-date\n"
"Examining jive.c...non-existent...out-of-date\n"
"--- jive.c ---\n"
"lex jive.l\n"
"... meaningless lex output deleted ...\n"
"mv lex.yy.c jive.c\n"
"Examining jive.o...non-existent...out-of-date\n"
"--- jive.o ---\n"
"cc -c jive.c\n"
"Examining jive.out...non-existent...out-of-date\n"
"--- jive.out ---\n"
"cc -o jive.out jive.o"
msgstr ""

#. (itstool) path: para/buildtarget
#. (itstool) path: entry/buildtarget
#: book.translate.xml:1952 book.translate.xml:2578
msgid ".NULL"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1947
msgid ""
"One final question remains: what does <application>PMake</application> do "
"with targets that have no known suffix? <application>PMake</application> "
"simply pretends it actually has a known suffix and searches for "
"transformations accordingly. The suffix it chooses is the source for the <_:"
"buildtarget-1/> target mentioned later. In the system makefile, <filename>."
"out</filename> is chosen as the <quote>null suffix</quote> because most "
"people use <application>PMake</application> to create programs. You are, "
"however, free and welcome to change it to a suffix of your own choosing. The "
"null suffix is ignored, however, when <application>PMake</application> is in "
"compatibility mode (see <xref linkend=\"gods\"/>)."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:1963
msgid "Including Other Makefiles"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1965
msgid ""
"Just as for programs, it is often useful to extract certain parts of a "
"makefile into another file and just include it in other makefiles somehow. "
"Many compilers allow you say something like:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:1970
#, no-wrap
msgid "#include \"defs.h\""
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1972
msgid ""
"to include the contents of <filename>defs.h</filename> in the source file. "
"<application>PMake</application> allows you to do the same thing for "
"makefiles, with the added ability to use variables in the filenames. An "
"include directive in a makefile looks either like this:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:1978
#, no-wrap
msgid "#include &lt;file&gt;"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1980
msgid "or this:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:1982
#, no-wrap
msgid "#include \"file\""
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:1984
msgid ""
"The difference between the two is where <application>PMake</application> "
"searches for the file: the first way, <application>PMake</application> will "
"look for the file only in the system makefile directory (or directories) (to "
"find out what that directory is, give <application>PMake</application> the "
"<filename>-h</filename> flag). The system makefile directory search path can "
"be overridden via the <option>-m</option> option. For files in double-"
"quotes, the search is more complex:"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1996
msgid "The directory of the makefile that's including the file."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:2001
msgid ""
"The current directory (the one in which you invoked <application>PMake</"
"application>)."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:2006
msgid ""
"The directories given by you using <option>-I</option> flags, in the order "
"in which you gave them."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:2012
msgid ""
"Directories given by <varname>.PATH</varname> dependency lines (see <xref "
"linkend=\"gods\"/>)."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:2018
msgid "The system makefile directory."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2022
msgid "in that order."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2024
msgid ""
"You are free to use <application>PMake</application> variables in the "
"filename – <application>PMake</application> will expand them before "
"searching for the file. You must specify the searching method with either "
"angle brackets or double-quotes outside of a variable expansion. I.e. the "
"following:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:2030
#, no-wrap
msgid "SYSTEM    = &lt;command.mk&gt;\n"
"\n"
"#include $(SYSTEM)"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2034
msgid "will not work."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:2038
msgid "Saving Commands"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2040
msgid ""
"There may come a time when you will want to save certain commands to be "
"executed when everything else is done. For instance: you are making several "
"different libraries at one time and you want to create the members in "
"parallel. Problem is, <application>ranlib</application> is another one of "
"those programs that can not be run more than once in the same directory at "
"the same time (each one creates a file called <filename>__.SYMDEF</filename> "
"into which it stuffs information for the linker to use. Two of them running "
"at once will overwrite each other's file and the result will be garbage for "
"both parties). You might want a way to save the ranlib commands til the end "
"so they can be run one after the other, thus keeping them from trashing each "
"other's file. <application>PMake</application> allows you to do this by "
"inserting an ellipsis (<quote>...</quote>) as a command between commands to "
"be run at once and those to be run later."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2057
msgid ""
"So for the <application>ranlib</application> case above, you might do this:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:2060
#, no-wrap
msgid ""
"lib1.a          : $(LIB1OBJS)\n"
"\trm -f $(.TARGET)\n"
"\tar cr $(.TARGET) $(.ALLSRC)\n"
"\t...\n"
"\tranlib $(.TARGET)\n"
"\n"
"lib2.a          : $(LIB2OBJS)\n"
"\trm -f $(.TARGET)\n"
"\tar cr $(.TARGET) $(.ALLSRC)\n"
"\t...\n"
"\tranlib $(.TARGET)"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2072
msgid "This would save both"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:2074
#, no-wrap
msgid "ranlib $(.TARGET)"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2076
msgid ""
"commands until the end, when they would run one after the other (using the "
"correct value for the <varname>.TARGET</varname> variable, of course)."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2080
msgid ""
"Commands saved in this manner are only executed if <application>PMake</"
"application> manages to re-create everything without an error."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:2086
msgid "Target Attributes"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2088
msgid ""
"<application>PMake</application> allows you to give attributes to targets by "
"means of special sources. Like everything else <application>PMake</"
"application> uses, these sources begin with a period and are made up of all "
"upper-case letters. There are various reasons for using them, and I will try "
"to give examples for most of them. Others you will have to find uses for "
"yourself. Think of it as <quote>an exercise for the reader</quote>. By "
"placing one (or more) of these as a source on a dependency line, you are "
"<quote>marking the target(s) with that attribute</quote>. That is just the "
"way I phrase it, so you know."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2100
msgid ""
"Any attributes given as sources for a transformation rule are applied to the "
"target of the transformation rule when the rule is applied."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2111
msgid "<literal>.DONTCARE</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2113
msgid ""
"If a target is marked with this attribute and <application>PMake</"
"application> can not figure out how to create it, it will ignore this fact "
"and assume the file is not really needed or actually exists and "
"<application>PMake</application> just can not find it. This may prove wrong, "
"but the error will be noted later on, not when <application>PMake</"
"application> tries to create the target so marked. This attribute also "
"prevents <application>PMake</application> from attempting to touch the "
"target if it is given the <option>-t</option> flag."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2127
msgid "<literal>.EXEC</literal>"
msgstr ""

#. (itstool) path: para/buildtarget
#: book.translate.xml:2142
msgid "COMPILE"
msgstr ""

#. (itstool) path: para/programlisting
#: book.translate.xml:2145
#, no-wrap
msgid ""
"system          : init a.fasl b.fasl c.fasl\n"
"\tfor i in $(.ALLSRC);\n"
"\tdo\n"
"\t\techo -n '(load \"' &gt;&gt; input\n"
"\t\techo -n ${i} &gt;&gt; input\n"
"\t\techo '\")' &gt;&gt; input\n"
"\tdone\n"
"\techo '(dump \"$(.TARGET)\")' &gt;&gt; input\n"
"\tlisp &lt; input\n"
"\n"
"a.fasl          : a.l init COMPILE\n"
"b.fasl          : b.l init COMPILE\n"
"c.fasl          : c.l init COMPILE\n"
"COMPILE         : .USE\n"
"\techo '(compile \"$(.ALLSRC)\")' &gt;&gt; input\n"
"init            : .EXEC\n"
"\techo '(load-system)' &gt; input"
msgstr ""

#. (itstool) path: entry/para
#: book.translate.xml:2129
msgid ""
"This attribute causes its shell script to be executed while having no effect "
"on targets that depend on it. This makes the target into a sort of "
"subroutine. An example. Say you have some LISP files that need to be "
"compiled and loaded into a LISP process. To do this, you echo LISP commands "
"into a file and execute a LISP with this file as its input when everything "
"is done. Say also that you have to load other files from another system "
"before you can compile your files and further, that you do not want to go "
"through the loading and dumping unless one of your files has changed. Your "
"makefile might look a little bit like this (remember, this is an educational "
"example, and do not worry about the <_:buildtarget-1/> rule, all will soon "
"become clear, grasshopper): <_:programlisting-2/> <literal>.EXEC</literal> "
"sources, do not appear in the local variables of targets that depend on them "
"(nor are they touched if <application>PMake</application> is given the "
"<option>-t</option> flag). Note that all the rules, not just that for "
"system, include init as a source. This is because none of the other targets "
"can be made until init has been made, thus they depend on it."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2174
msgid "<literal>.EXPORT</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2176
msgid ""
"This is used to mark those targets whose creation should be sent to another "
"machine if at all possible. This may be used by some exportation schemes if "
"the exportation is expensive. You should ask your system administrator if it "
"is necessary."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2185
msgid "<literal>.EXPORTSAME</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2187
msgid ""
"Tells the export system that the job should be exported to a machine of the "
"same architecture as the current one. Certain operations (e.g. running text "
"through nroff) can be performed the same on any architecture (CPU and "
"operating system type), while others (e.g. compiling a program with cc) must "
"be performed on a machine with the same architecture. Not all export systems "
"will support this attribute."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2199
msgid "<literal>.IGNORE</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2201
msgid ""
"Giving a target the <literal>.IGNORE</literal> attribute causes "
"<application>PMake</application> to ignore errors from any of the target's "
"commands, as if they all had <literal>-</literal> before them."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2209
msgid "<literal>.INVISIBLE</literal>"
msgstr ""

#. (itstool) path: para/programlisting
#: book.translate.xml:2218
#, no-wrap
msgid ""
"prog1           : $(PROG1OBJS) prog2 MAKEINSTALL\n"
"prog2           : $(PROG2OBJS) .INVISIBLE MAKEINSTALL"
msgstr ""

#. (itstool) path: para/buildtarget
#: book.translate.xml:2226
msgid "prog2"
msgstr ""

#. (itstool) path: entry/para
#: book.translate.xml:2211
msgid ""
"This allows you to specify one target as a source for another without the "
"one affecting the other's local variables. Useful if, say, you have a "
"makefile that creates two programs, one of which is used to create the "
"other, so it must exist before the other is created. You could say <_:"
"programlisting-1/> where <literal>MAKEINSTALL</literal> is some complex "
"<literal>.USE</literal> rule (see below) that depends on the <varname>."
"ALLSRC</varname> variable containing the right things. Without the <literal>."
"INVISIBLE</literal> attribute for <_:buildtarget-2/>, the "
"<literal>MAKEINSTALL</literal> rule could not be applied. This is not as "
"useful as it should be, and the semantics may change (or the whole thing go "
"away) in the not-too-distant future."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2235
msgid "<literal>.JOIN</literal>"
msgstr ""

#. (itstool) path: para/programlisting
#: book.translate.xml:2257
#, no-wrap
msgid ""
"program         : $(OBJS) libraries\n"
"\tcc -o $(.TARGET) $(.ALLSRC)\n"
"\n"
"libraries       : lib1.a lib2.a lib3.a lib4.a .JOIN\n"
"\tranlib $(.OODATE)"
msgstr ""

#. (itstool) path: entry/para
#: book.translate.xml:2237
msgid ""
"This is another way to avoid performing some operations in parallel while "
"permitting everything else to be done so. Specifically it forces the "
"target's shell script to be executed only if one or more of the sources was "
"out-of-date. In addition, the target's name, in both its <varname>.TARGET</"
"varname> variable and all the local variables of any target that depends on "
"it, is replaced by the value of its <varname>.ALLSRC</varname> variable. As "
"an example, suppose you have a program that has four libraries that compile "
"in the same directory along with, and at the same time as, the program. You "
"again have the problem with ranlib that I mentioned earlier, only this time "
"it is more severe: you can not just put the ranlib off to the end since the "
"program will need those libraries before it can be re-created. You can do "
"something like this: <_:programlisting-1/> In this case, <application>PMake</"
"application> will re-create the <literal>$(OBJS)</literal> as necessary, "
"along with <filename>lib1.a</filename>, <filename>lib2.a</filename>, "
"<filename>lib3.a</filename> and <filename>lib4.a</filename>. It will then "
"execute ranlib on any library that was changed and set program's <varname>."
"ALLSRC</varname> variable to contain what's in <literal>$(OBJS)</literal> "
"followed by <quote><filename>lib1.a</filename> <filename>lib2.a</filename> "
"<filename>lib3.a</filename> <filename>lib4.a</filename>.</quote> In case you "
"are wondering, it is called <literal>.JOIN</literal> because it joins "
"together different threads of the <quote>input graph</quote> at the target "
"marked with the attribute. Another aspect of the <literal>.JOIN</literal> "
"attribute is it keeps the target from being created if the <option>-t</"
"option> flag was given."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2287
msgid "<literal>.MAKE</literal>"
msgstr ""

#. (itstool) path: para/literallayout
#: book.translate.xml:2299
#, no-wrap
msgid "<command>pmake -n</command>"
msgstr ""

#. (itstool) path: entry/para
#: book.translate.xml:2289
msgid ""
"The <literal>.MAKE</literal> attribute marks its target as being a recursive "
"invocation of PMake. This forces <application>PMake</application> to execute "
"the script associated with the target (if it is out-of-date) even if you "
"gave the <option>-n</option> or <option>-t</option> flag. By doing this, you "
"can start at the top of a system and type <_:literallayout-1/> and have it "
"descend the directory tree (if your makefiles are set up correctly), "
"printing what it would have executed if you had not included the <option>-n</"
"option> flag."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2308
msgid "<literal>.NOEXPORT</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2310
msgid ""
"If possible, <application>PMake</application> will attempt to export the "
"creation of all targets to another machine (this depends on how "
"<application>PMake</application> was configured). Sometimes, the creation is "
"so simple, it is pointless to send it to another machine. If you give the "
"target the <literal>.NOEXPORT</literal> attribute, it will be run loally, "
"even if you have given <application>PMake</application> the <option>-L 0</"
"option> flag."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2324
msgid "<literal>.NOTMAIN</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2326
msgid ""
"Normally, if you do not specify a target to make in any other way, "
"<application>PMake</application> will take the first target on the first "
"dependency line of a makefile as the target to create. That target is known "
"as the <quote>Main Target</quote> and is labeled as such if you print the "
"dependencies out using the <option>-p</option> flag. Giving a target this "
"attribute tells <application>PMake</application> that the target is "
"definitely not the Main Target. This allows you to place targets in an "
"included makefile and have <application>PMake</application> create something "
"else by default."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2342
msgid "<literal>.PRECIOUS</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2344
msgid ""
"When <application>PMake</application> is interrupted (you type control-C at "
"the keyboard), it will attempt to clean up after itself by removing any half-"
"made targets. If a target has the <literal>.PRECIOUS</literal> attribute, "
"however, <application>PMake</application> will leave it alone. An additional "
"side effect of the <literal>::</literal> operator is to mark the targets as "
"<literal>.PRECIOUS</literal>."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2356
msgid "<literal>.SILENT</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2358
msgid ""
"Marking a target with this attribute keeps its commands from being printed "
"when they are executed, just as if they had an <literal>@</literal> in front "
"of them."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2365
msgid "<literal>.USE</literal>"
msgstr ""

#. (itstool) path: para/programlisting
#: book.translate.xml:2388
#, no-wrap
msgid ""
"lib1.a          : $(LIB1OBJS) MAKELIB\n"
"lib2.a          : $(LIB2OBJS) MAKELIB\n"
"\n"
"MAKELIB         : .USE\n"
"\trm -f $(.TARGET)\n"
"\tar cr $(.TARGET) $(.ALLSRC)\n"
"\t...\n"
"\tranlib $(.TARGET)"
msgstr ""

#. (itstool) path: para/buildtarget
#: book.translate.xml:2403 book.translate.xml:2406
msgid "MAKELIB"
msgstr ""

#. (itstool) path: entry/para
#: book.translate.xml:2367
msgid ""
"By giving a target this attribute, you turn it into <application/>PMake's "
"equivalent of a macro. When the target is used as a source for another "
"target, the other target acquires the commands, sources and attributes "
"(except <literal>.USE</literal>) of the source. If the target already has "
"commands, the <literal>.USE</literal> target's commands are added to the end."
" If more than one <literal>.USE</literal>-marked source is given to a "
"target, the rules are applied sequentially. The typical <literal>.USE</"
"literal> rule (as I call them) will use the sources of the target to which "
"it is applied (as stored in the <varname>.ALLSRC</varname> variable for the "
"target) as its <quote>arguments,</quote> if you will. For example, you "
"probably noticed that the commands for creating <filename>lib1.a</filename> "
"and <filename>lib2.a</filename> in the example in section <xref linkend="
"\"savingcmds\"/> were exactly the same. You can use the <literal>.USE</"
"literal> attribute to eliminate the repetition, like so: <_:programlisting-1/"
"> Several system makefiles (not to be confused with The System Makefile) "
"make use of these <literal>.USE</literal> rules to make your life easier "
"(they are in the default, system makefile directory...take a look). Note "
"that the <literal>.USE</literal> rule source itself (<_:buildtarget-2/>) "
"does not appear in any of the targets's local variables. There is no limit "
"to the number of times I could use the <_:buildtarget-3/> rule. If there "
"were more libraries, I could continue with <literal>lib3.a : $(LIB3OBJS) "
"MAKELIB</literal> and so on and so forth."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:2417
msgid "Special Targets"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2419
msgid ""
"As there were in <application>Make</application>, so there are certain "
"targets that have special meaning to <application>PMake</application>. When "
"you use one on a dependency line, it is the only target that may appear on "
"the left-hand-side of the operator. As for the attributes and variables, all "
"the special targets begin with a period and consist of upper-case letters "
"only. I will not describe them all in detail because some of them are rather "
"complex and I will describe them in more detail than you will want in <xref "
"linkend=\"gods\"/>. The targets are as follows:"
msgstr ""

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2437 book.translate.xml:2465
msgid ".BEGIN"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2439
msgid ""
"Any commands attached to this target are executed before anything else is "
"done. You can use it for any initialization that needs doing."
msgstr ""

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2446 book.translate.xml:2454 book.translate.xml:2456
msgid ".DEFAULT"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2448
msgid ""
"This is sort of a <literal>.USE</literal> rule for any target (that was used "
"only as a source) that <application>PMake</application> can not figure out "
"any other way to create. It is only <quote>sort of</quote> a <literal>.USE</"
"literal> rule because only the shell script attached to the <_:buildtarget-1/"
"> target is used. The <varname>.IMPSRC</varname> variable of a target that "
"inherits <_:buildtarget-2/>'s commands is set to the target's own name."
msgstr ""

#. (itstool) path: entry/buildtarget
#. (itstool) path: para/buildtarget
#: book.translate.xml:2462 book.translate.xml:3811
msgid ".END"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2464
msgid ""
"This serves a function similar to <_:buildtarget-1/>, in that commands "
"attached to it are executed once everything has been re-created (so long as "
"no errors occurred). It also serves the extra function of being a place on "
"which <application>PMake</application> can hang commands you put off to the "
"end. Thus the script for this target will be executed before any of the "
"commands you save with the <quote>...</quote>."
msgstr ""

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2477
msgid ".EXPORT"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2479
msgid ""
"The sources for this target are passed to the exportation system compiled "
"into <application>PMake</application>. Some systems will use these sources "
"to configure themselves. You should ask your system administrator about this."
""
msgstr ""

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2487 book.translate.xml:2615
msgid ".IGNORE"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2489
msgid ""
"This target marks each of its sources with the <literal>.IGNORE</literal> "
"attribute. If you do not give it any sources, then it is like giving the "
"<option>-i</option> flag when you invoke <application>PMake</application> – "
"errors are ignored for all commands."
msgstr ""

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2498 book.translate.xml:2542
msgid ".INCLUDES"
msgstr ""

#. (itstool) path: para/buildtarget
#. (itstool) path: entry/buildtarget
#: book.translate.xml:2506 book.translate.xml:2589 book.translate.xml:2605
#: book.translate.xml:2901 book.translate.xml:2912 book.translate.xml:2916
msgid ".PATH"
msgstr ""

#. (itstool) path: para/programlisting
#: book.translate.xml:2514
#, no-wrap
msgid ""
".SUFFIXES       : .bitmap\n"
".PATH.bitmap    : /usr/local/X/lib/bitmaps\n"
".INCLUDES       : .bitmap"
msgstr ""

#. (itstool) path: para/programlisting
#: book.translate.xml:2523
#, no-wrap
msgid "cc $(.INCLUDES) -c xprogram.c"
msgstr ""

#. (itstool) path: entry/para
#: book.translate.xml:2500
msgid ""
"The sources for this target are taken to be suffixes that indicate a file "
"that can be included in a program source file. The suffix must have already "
"been declared with <literal>.SUFFIXES</literal> (see below). Any suffix so "
"marked will have the directories on its search path (see <_:buildtarget-1/>, "
"below) placed in the <varname>.INCLUDES</varname> variable, each preceded by "
"a <option>-I</option> flag. This variable can then be used as an argument "
"for the compiler in the normal fashion. The <filename>.h</filename> suffix "
"is already marked in this way in the system makefile. E.g. if you have <_:"
"programlisting-2/> <application>PMake</application> will place <literal>-I/"
"usr/local/X/lib/bitmaps</literal> in the <varname>.INCLUDES</varname> "
"variable and you can then say <_:programlisting-3/> (Note: the <varname>."
"INCLUDES</varname> variable is not actually filled in until the entire "
"makefile has been read.)"
msgstr ""

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2531
msgid ".INTERRUPT"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2533
msgid ""
"When <application>PMake</application> is interrupted, it will execute the "
"commands in the script for this target, if it exists."
msgstr ""

#. (itstool) path: entry/buildtarget
#. (itstool) path: para/buildtarget
#: book.translate.xml:2539 book.translate.xml:3009
msgid ".LIBS"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2541
msgid ""
"This does for libraries what <_:buildtarget-1/> does for include files, "
"except the flag used is <option>-L</option>, as required by those linkers "
"that allow you to tell them where to find libraries. The variable used is "
"<varname>.LIBS</varname>. Be forewarned that <application>PMake</"
"application> may not have been compiled to do this if the linker on your "
"system does not accept the <option>-L</option> flag, though the <varname>."
"LIBS</varname> variable will always be defined once the makefile has been "
"read."
msgstr ""

#. (itstool) path: entry/buildtarget
#. (itstool) path: para/buildtarget
#: book.translate.xml:2556 book.translate.xml:3178 book.translate.xml:3180
#: book.translate.xml:3774
msgid ".MAIN"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2558
msgid ""
"If you did not give a target (or targets) to create when you invoked "
"<application>PMake</application>, it will take the sources of this target as "
"the targets to create."
msgstr ""

#. (itstool) path: entry/buildtarget
#. (itstool) path: para/buildtarget
#: book.translate.xml:2566 book.translate.xml:3656
msgid ".MAKEFLAGS"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2568
msgid ""
"This target provides a way for you to always specify flags for "
"<application>PMake</application> when the makefile is used. The flags are "
"just as they would be typed to the shell (except you can not use shell "
"variables unless they are in the environment), though the <option>-f</"
"option> and <option>-r</option> flags have no effect."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2580
msgid ""
"This allows you to specify what suffix <application>PMake</application> "
"should pretend a file has if, in fact, it has no known suffix. Only one "
"suffix may be so designated. The last source on the dependency line is the "
"suffix that is used (you should, however, only give one suffix...)."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2591
msgid ""
"If you give sources for this target, <application>PMake</application> will "
"take them as directories in which to search for files it cannot find in the "
"current directory. If you give no sources, it will clear out any directories "
"added to the search path before. Since the effects of this all get very "
"complex, we will leave it till <xref linkend=\"gods\"/> to give you a "
"complete explanation."
msgstr ""

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2602 book.translate.xml:3203
msgid ".PATH<replaceable>suffix</replaceable>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2604
msgid ""
"This does a similar thing to <_:buildtarget-1/>, but it does it only for "
"files with the given suffix. The suffix must have been defined already. Look "
"at Search Paths (<xref linkend=\"searchpaths\"/>) for more information."
msgstr ""

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2613
msgid ".PRECIOUS"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2615
msgid ""
"Similar to <_:buildtarget-1/>, this gives the <literal>.PRECIOUS</literal> "
"attribute to each source on the dependency line, unless there are no "
"sources, in which case the <literal>.PRECIOUS</literal> attribute is given "
"to every target in the file."
msgstr ""

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2623
msgid ".RECURSIVE"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2625
msgid ""
"This target applies the <literal>.MAKE</literal> attribute to all its "
"sources. It does nothing if you do not give it any sources."
msgstr ""

#. (itstool) path: entry/buildtarget
#. (itstool) path: para/buildtarget
#: book.translate.xml:2631 book.translate.xml:3348
msgid ".SHELL"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2633
msgid ""
"<application>PMake</application> is not constrained to only using the Bourne "
"shell to execute the commands you put in the makefile. You can tell it some "
"other shell to use with this target. Check out <quote><xref linkend="
"\"ashell\" endterm=\"ashelltitle\"/></quote> (<xref linkend=\"ashell\"/>) "
"for more information."
msgstr ""

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2642 book.translate.xml:2645
msgid ".SILENT"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2644
msgid ""
"When you use <_:buildtarget-1/> as a target, it applies the <literal>."
"SILENT</literal> attribute to each of its sources. If there are no sources "
"on the dependency line, then it is as if you gave <application>PMake</"
"application> the <option>-s</option> flag and no commands will be echoed."
msgstr ""

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2655 book.translate.xml:2662
msgid ".SUFFIXES"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2657
msgid ""
"This is used to give new file suffixes for <application>PMake</application> "
"to handle. Each source is a suffix <application>PMake</application> should "
"recognize. If you give a <_:buildtarget-1/> dependency line with no sources, "
"<application>PMake</application> will forget about all the suffixes it knew "
"(this also nukes the null suffix). For those targets that need to have "
"suffixes defined, this is how you do it."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2673
msgid "In addition to these targets, a line of the form:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:2675
#, no-wrap
msgid "attribute : sources"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2677
msgid "applies the attribute to all the targets listed as sources."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:2681
msgid "Modifying Variable Expansion"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2683
msgid ""
"Variables need not always be expanded verbatim. <application>PMake</"
"application> defines several modifiers that may be applied to a variable's "
"value before it is expanded. You apply a modifier by placing it after the "
"variable name with a colon between the two, like so:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:2689
#, no-wrap
msgid "${VARIABLE:modifier}"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2691
msgid ""
"Each modifier is a single character followed by something specific to the "
"modifier itself. You may apply as many modifiers as you want – each one is "
"applied to the result of the previous and is separated from the previous by "
"another colon."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2697
msgid ""
"There are seven ways to modify a variable's expansion, most of which come "
"from the C shell variable modification characters:"
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:2703
msgid "<literal>Mpattern</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:2706
msgid ""
"This is used to select only those words (a word is a series of characters "
"that are neither spaces nor tabs) that match the given pattern. The pattern "
"is a wildcard pattern like that used by the shell, where <literal>*</"
"literal> means <literal>0</literal> or more characters of any sort; "
"<literal>?</literal> is any single character; <literal>[abcd]</literal> "
"matches any single character that is either <literal>a</literal>, "
"<literal>b</literal>, <literal>c</literal> or <literal>d</literal> (there "
"may be any number of characters between the brackets); <literal>[0-9]</"
"literal> matches any single character that is between <literal>0</literal> "
"and <literal>9</literal> (i.e. any digit. This form may be freely mixed with "
"the other bracket form), and <literal>\\</literal> is used to escape any of "
"the characters <literal>*</literal>, <literal>?</literal>, <literal>[</"
"literal> or <literal>:</literal>, leaving them as regular characters to "
"match themselves in a word. For example, the system makefile "
"<filename>&lt;makedepend.mk&gt;</filename> uses <literal>$(CFLAGS:M-[ID]*)</"
"literal> to extract all the <option>-I</option> and <option>-D</option> "
"flags that would be passed to the C compiler. This allows it to properly "
"locate include files and generate the correct dependencies."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:2736
msgid "<literal>Npattern</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:2739
msgid ""
"This is identical to <literal>:M</literal> except it substitutes all words "
"that do not match the given pattern."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:2746
msgid "<literal>S/search-string/replacement-string/[g]</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:2749
msgid ""
"Causes the first occurrence of search-string in the variable to be replaced "
"by replacement-string, unless the <option>g</option> flag is given at the "
"end, in which case all occurrences of the string are replaced. The "
"substitution is performed on each word in the variable in turn. If search-"
"string begins with a <literal>^</literal>, the string must match starting at "
"the beginning of the word. If search-string ends with a <literal>$</"
"literal>, the string must match to the end of the word (these two may be "
"combined to force an exact match). If a backslash precedes these two "
"characters, however, they lose their special meaning. Variable expansion "
"also occurs in the normal fashion inside both the search-string and the "
"replacement-string, except that a backslash is used to prevent the expansion "
"of a <literal>$</literal>, not another dollar sign, as is usual. Note that "
"search-string is just a string, not a pattern, so none of the usual "
"regularexpression/wildcard characters have any special meaning save "
"<literal>^</literal> and <literal>$</literal>. In the replacement string, "
"the <literal>&amp;</literal> character is replaced by the search-string "
"unless it is preceded by a backslash. You are allowed to use any character "
"except colon or exclamation point to separate the two strings. This so-"
"called delimiter character may be placed in either string by preceding it "
"with a backslash."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:2780
msgid "<literal>T</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:2783
msgid ""
"Replaces each word in the variable expansion by its last component (its "
"<quote>tail</quote>). For example, given:"
msgstr ""

#. (itstool) path: listitem/programlisting
#: book.translate.xml:2787
#, no-wrap
msgid "OBJS = ../lib/a.o b /usr/lib/libm.a\n"
"TAILS = $(OBJS:T)"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:2790
msgid ""
"the variable <varname>TAILS</varname> would expand to <literal>a.o b libm.a."
"</literal>"
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:2796
msgid "<literal>H</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:2799
msgid ""
"This is similar to <literal>:T</literal>, except that every word is replaced "
"by everything but the tail (the <quote>head</quote>). Using the same "
"definition of <varname>OBJS</varname>, the string <literal>$(OBJS:H)</"
"literal> would expand to <literal>../lib /usr/lib.</literal> Note that the "
"final slash on the heads is removed and anything without a head is replaced "
"by the empty string."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:2811
msgid "<literal>E</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:2814
msgid ""
"<literal>:E</literal> replaces each word by its suffix (<quote>extension</"
"quote>). So <literal>$(OBJS:E)</literal> would give you <literal>.o .a.</"
"literal>"
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:2822
msgid "<literal>R</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:2825
msgid ""
"This replaces each word by everything but the suffix (the <quote>root</"
"quote> of the word). <literal>$(OBJS:R)</literal> expands to <literal>../lib/"
"a b /usr/lib/libm</literal>."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2833
msgid ""
"In addition, the System V style of substitution is also supported. This "
"looks like:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:2836
#, no-wrap
msgid "$(VARIABLE:search-string=replacement)"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2838
msgid ""
"It must be the last modifier in the chain. The search is anchored at the end "
"of each word, so only suffixes or whole words may be replaced."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:2844
msgid "More Exercises"
msgstr ""

#. (itstool) path: section/bridgehead
#. (itstool) path: chapter/bridgehead
#: book.translate.xml:2846 book.translate.xml:3829
msgid "Exercise 3.1"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2848
msgid ""
"You have got a set programs, each of which is created from its own assembly-"
"language source file (suffix <filename>.asm</filename>). Each program can be "
"assembled into two versions, one with error-checking code assembled in and "
"one without. You could assemble them into files with different suffixes "
"(<filename>.eobj</filename> and <filename>.obj</filename>, for instance), "
"but your linker only understands files that end in <filename>.obj</filename>."
" To top it all off, the final executables must have the suffix <filename>."
"exe</filename>. How can you still use transformation rules to make your life "
"easier (Hint: assume the errorchecking versions have ec tacked onto their "
"prefix)?"
msgstr ""

#. (itstool) path: section/bridgehead
#: book.translate.xml:2861
msgid "Exercise 3.2"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2863
msgid ""
"Assume, for a moment or two, you want to perform a sort of "
"<quote>indirection</quote> by placing the name of a variable into another "
"one, then you want to get the value of the first by expanding the second "
"somehow. Unfortunately, <application>PMake</application> does not allow "
"constructs like:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:2869
#, no-wrap
msgid "$($(FOO))"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2871
msgid ""
"What do you do? Hint: no further variable expansion is performed after "
"modifiers are applied, thus if you cause a <literal>$</literal> to occur in "
"the expansion, that is what will be in the result."
msgstr ""

#. (itstool) path: chapter/title
#: book.translate.xml:2883
msgid "PMake for Gods"
msgstr ""

#. (itstool) path: chapter/para
#: book.translate.xml:2885
msgid ""
"This chapter is devoted to those facilities in <application>PMake</"
"application> that allow you to do a great deal in a makefile with very "
"little work, as well as do some things you could not do in "
"<application>Make</application> without a great deal of work (and perhaps "
"the use of other programs). The problem with these features, is they must be "
"handled with care, or you will end up with a mess."
msgstr ""

#. (itstool) path: chapter/para
#: book.translate.xml:2893
msgid ""
"Once more, I assume a greater familiarity with <trademark class="
"\"registered\">UNIX</trademark> or Sprite than I did in the previous two "
"chapters."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:2897
msgid "Search Paths"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2899
msgid ""
"<application>PMake</application> supports the dispersal of files into "
"multiple directories by allowing you to specify places to look for sources "
"with <_:buildtarget-1/> targets in the makefile. The directories you give as "
"sources for these targets make up a <quote>search path</quote>. Only those "
"files used exclusively as sources are actually sought on a search path, the "
"assumption being that anything listed as a target in the makefile can be "
"created by the makefile and thus should be in the current directory."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2909
msgid ""
"There are two types of search paths in <application>PMake</application>: one "
"is used for all types of files (including included makefiles) and is "
"specified with a plain <_:buildtarget-1/> target (e.g. <literal>.PATH : RCS</"
"literal>), while the other is specific to a certain type of file, as "
"indicated by the file's suffix. A specific search path is indicated by "
"immediately following the <_:buildtarget-2/> with the suffix of the file. "
"For instance:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:2919
#, no-wrap
msgid ".PATH.h         : /sprite/lib/include /sprite/att/lib/include"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2921
msgid ""
"would tell <application>PMake</application> to look in the directories "
"<filename>/sprite/lib/include</filename> and <filename>/sprite/att/lib/"
"include</filename> for any files whose suffix is <filename>.h</filename>."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2926
msgid ""
"The current directory is always consulted first to see if a file exists. "
"Only if it cannot be found there are the directories in the specific search "
"path, followed by those in the general search path, consulted."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2931
msgid ""
"A search path is also used when expanding wildcard characters. If the "
"pattern has a recognizable suffix on it, the path for that suffix will be "
"used for the expansion. Otherwise the default search path is employed."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2936
msgid ""
"When a file is found in some directory other than the current one, all local "
"variables that would have contained the target's name (<varname>.ALLSRC</"
"varname>, and <varname>.IMPSRC</varname>) will instead contain the path to "
"the file, as found by <application>PMake</application>. Thus if you have a "
"file <filename>../lib/mumble.c</filename> and a makefile like this:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:2945
#, no-wrap
msgid ""
".PATH.c         : ../lib\n"
"mumble          : mumble.c\n"
"\t$(CC) -o $(.TARGET) $(.ALLSRC)"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2949
msgid ""
"the command executed to create mumble would be <command>cc -o mumble ../lib/"
"mumble.c.</command> (as an aside, the command in this case is not strictly "
"necessary, since it will be found using transformation rules if it is not "
"given. This is because <filename>.out</filename> is the null suffix by "
"default and a transformation exists from <filename>.c</filename> to "
"<filename>.out</filename>. Just thought I would throw that in). If a file "
"exists in two directories on the same search path, the file in the first "
"directory on the path will be the one <application>PMake</application> uses. "
"So if you have a large system spread over many directories, it would behoove "
"you to follow a naming convention that avoids such conflicts."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2964
msgid ""
"Something you should know about the way search paths are implemented is that "
"each directory is read, and its contents cached, exactly once – when it is "
"first encountered – so any changes to the directories while "
"<application>PMake</application> is running will not be noted when searching "
"for implicit sources, nor will they be found when <application>PMake</"
"application> attempts to discover when the file was last modified, unless "
"the file was created in the current directory. While people have suggested "
"that <application>PMake</application> should read the directories each time, "
"my experience suggests that the caching seldom causes problems. In addition, "
"not caching the directories slows things down enormously because of "
"<application>PMake</application>'s attempts to apply transformation rules "
"through non-existent files – the number of extra file-system searches is "
"truly staggering, especially if many files without suffixes are used and the "
"null suffix is not changed from <filename>.out</filename>."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:2984
msgid "Archives and Libraries"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2986
msgid ""
"<trademark class=\"registered\">UNIX</trademark> and Sprite allow you to "
"merge files into an archive using the <command>ar</command> command. "
"Further, if the files are relocatable object files, you can run "
"<application>ranlib</application> on the archive and get yourself a library "
"that you can link into any program you want. The main problem with archives "
"is they double the space you need to store the archived files, since there "
"is one copy in the archive and one copy out by itself. The problem with "
"libraries is you usually think of them as <option>-lm</option> rather than "
"<filename>/usr/lib/libm.a</filename> and the linker thinks they are out-of-"
"date if you so much as look at them."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:2998
msgid ""
"<application>PMake</application> solves the problem with archives by "
"allowing you to tell it to examine the files in the archives (so you can "
"remove the individual files without having to regenerate them later). To "
"handle the problem with libraries, <application>PMake</application> adds an "
"additional way of deciding if a library is out-of-date: if the table of "
"contents is older than the library, or is missing, the library is out-of-"
"date."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3007
msgid ""
"A library is any target that looks like <option>-lname</option> or that ends "
"in a suffix that was marked as a library using the <_:buildtarget-1/> target."
" <filename>.a</filename> is so marked in the system makefile. Members of an "
"archive are specified as <literal>archive(member[member...])</literal>. Thus "
"<literal>libdix.a(window.o)</literal> specifies the file <filename>window.o</"
"filename> in the archive <filename>libdix.a</filename>. You may also use "
"wildcards to specify the members of the archive. Just remember that most the "
"wildcard characters will only find existing files. A file that is a member "
"of an archive is treated specially. If the file does not exist, but it is in "
"the archive, the modification time recorded in the archive is used for the "
"file when determining if the file is out-of-date. When figuring out how to "
"make an archived member target (not the file itself, but the file in the "
"archive – the archive(member) target), special care is taken with the "
"transformation rules, as follows:"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3028
msgid "archive(member) is made to depend on member."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3032
msgid ""
"The transformation from the member's suffix to the archive's suffix is "
"applied to the archive(member) target."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3037
msgid ""
"The archive(member)'s <varname>.TARGET</varname> variable is set to the name "
"of the member if member is actually a target, or the path to the member file "
"if member is only a source."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3044
msgid ""
"The <varname>.ARCHIVE</varname> variable for the archive(member) target is "
"set to the name of the archive."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3050
msgid ""
"The <varname>.MEMBER</varname> variable is set to the actual string inside "
"the parentheses. In most cases, this will be the same as the <varname>."
"TARGET</varname> variable."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3057
msgid ""
"The archive(member)'s place in the local variables of the targets that "
"depend on it is taken by the value of its <varname>.TARGET</varname> "
"variable."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3063
msgid "Thus, a program library could be created with the following makefile:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:3066
#, no-wrap
msgid ""
".o.a            :\n"
"\t...\n"
"\trm -f $(.TARGET:T)\n"
"OBJS            = obj1.o obj2.o obj3.o\n"
"libprog.a       : libprog.a($(OBJS))\n"
"\tar cru $(.TARGET) $(.OODATE)\n"
"\tranlib $(.TARGET)"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3074
msgid ""
"This will cause the three object files to be compiled (if the corresponding "
"source files were modified after the object file or, if that does not exist, "
"the archived object file), the out-of-date ones archived in "
"<filename>libprog.a</filename>, a table of contents placed in the archive "
"and the newly-archived object files to be removed."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3081
msgid ""
"All this is used in the <filename>makelib.mk</filename> system makefile to "
"create a single library with ease. This makefile looks like this:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:3085
#, no-wrap
msgid ""
"#\n"
"# Rules for making libraries. The object files that make up the library\n"
"# are removed once they are archived.\n"
"#\n"
"# To make several libraries in parallel, you should define the variable\n"
"# \"many_libraries\". This will serialize the invocations of ranlib.\n"
"#\n"
"# To use, do something like this:\n"
"#\n"
"# OBJECTS = &lt;files in the library&gt;\n"
"#\n"
"# fish.a: fish.a($(OBJECTS)) MAKELIB\n"
"#\n"
"#\n"
"\n"
"#ifndef _MAKELIB_MK\n"
"_MAKELIB_MK    =\n"
"\n"
"#include  &lt;po.mk&gt;\n"
"\n"
".po.a .o.a     :\n"
"\t...\n"
"\trm -f $(.MEMBER)\n"
"\n"
"ARFLAGS        ?= crl\n"
"\n"
"#\n"
"# Re-archive the out-of-date members and recreate the library's table of\n"
"# contents using ranlib. If many_libraries is defined, put the ranlib\n"
"# off til the end so many libraries can be made at once.\n"
"#\n"
"MAKELIB        : .USE .PRECIOUS\n"
"\tar $(ARFLAGS) $(.TARGET) $(.OODATE)\n"
"#ifndef no_ranlib\n"
"# ifdef many_libraries\n"
"\t...\n"
"# endif many_libraries\n"
"\tranlib $(.TARGET)\n"
"#endif no_ranlib\n"
"\n"
"#endif _MAKELIB_MK"
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:3129
msgid "On the Condition..."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3131
msgid ""
"Like the C compiler before it, <application>PMake</application> allows you "
"to configure the makefile, based on the current environment, using "
"conditional statements. A conditional looks like this:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:3136
#, no-wrap
msgid ""
"#if boolean expression\n"
"lines\n"
"#elif another boolean expression\n"
"more lines\n"
"#else\n"
"still more lines\n"
"#endif"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3144
msgid ""
"They may be nested to a maximum depth of 30 and may occur anywhere (except "
"in a comment, of course). The <literal>#</literal> must the very first "
"character on the line."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3149
msgid ""
"Each boolean expression is made up of terms that look like function calls, "
"the standard C boolean operators <literal>&amp;&amp;</literal>, <literal>||</"
"literal>, and <literal>!</literal>, and the standard relational operators "
"<literal>==</literal>, <literal>!=</literal>, <literal>&gt;</literal>, "
"<literal>&gt;=</literal>, <literal>&lt;</literal>, and <literal>&lt;=</"
"literal>, with <literal>==</literal> and <literal>!=</literal> being "
"overloaded to allow string comparisons as well. <literal>&amp;&amp;</"
"literal> represents logical AND; <literal>||</literal> is logical OR and "
"<literal>!</literal> is logical NOT. The arithmetic and string operators "
"take precedence over all three of these operators, while NOT takes "
"precedence over AND, which takes precedence over OR. This precedence may be "
"overridden with parentheses, and an expression may be parenthesized to your "
"heart's content. Each term looks like a call on one of four functions:"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:3173 book.translate.xml:3282
msgid "<literal>make</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:3175
msgid ""
"The syntax is make(target) where target is a target in the makefile. This is "
"true if the given target was specified on the command line, or as the source "
"for a <_:buildtarget-1/> target (note that the sources for <_:buildtarget-2/"
"> are only used if no targets were given on the command line)."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:3186 book.translate.xml:3270
msgid "<literal>defined</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:3188
msgid ""
"The syntax is <literal>defined(variable)</literal> and is true if variable "
"is defined. Certain variables are defined in the system makefile that "
"identify the system on which <application>PMake</application> is being run."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:3197
msgid "<literal>exists</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:3199
msgid ""
"The syntax is <literal>exists(file)</literal> and is true if the file can be "
"found on the global search path (i.e. that defined by <varname>.PATH</"
"varname> targets, not by <_:buildtarget-1/> targets)."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:3208
msgid "<literal>empty</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:3210
msgid ""
"This syntax is much like the others, except the string inside the "
"parentheses is of the same form as you would put between parentheses when "
"expanding a variable, complete with modifiers and everything. The function "
"returns true if the resulting string is empty. An undefined variable in this "
"context will cause at the very least a warning message about a malformed "
"conditional, and at the worst will cause the process to stop once it has "
"read the makefile. If you want to check for a variable being defined or "
"empty, use the expression: <literal>!defined(var) || empty(var)</literal> as "
"the definition of <literal>||</literal> will prevent the <literal>empty()</"
"literal> from being evaluated and causing an error, if the variable is "
"undefined. This can be used to see if a variable contains a given word, for "
"example: <literal>#if !empty(var:Mword)</literal>"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3234
msgid ""
"The arithmetic and string operators may only be used to test the value of a "
"variable. The lefthand side must contain the variable expansion, while the "
"righthand side contains either a string, enclosed in double-quotes, or a "
"number. The standard C numeric conventions (except for specifying an octal "
"number) apply to both sides. E.g.:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:3241
#, no-wrap
msgid ""
"#if $(OS) == 4.3\n"
"\n"
"#if $(MACHINE) == \"sun3\"\n"
"\n"
"#if $(LOAD_ADDR) &gt; 0xc000"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3247
msgid ""
"are all valid conditionals. In addition, the numeric value of a variable can "
"be tested as a boolean as follows:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:3250
#, no-wrap
msgid "#if $(LOAD)"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3252
msgid "would see if <literal>LOAD</literal> contains a non-zero value and:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:3255
#, no-wrap
msgid "#if !$(LOAD)"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3257
msgid "would test if <literal>LOAD</literal> contains a zero value."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3260
msgid ""
"In addition to the bare <literal>#if</literal>, there are other forms that "
"apply one of the first two functions to each term. They are as follows:"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:3268
msgid "<literal>ifdef</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:3274
msgid "<literal>ifndef</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:3276
msgid "<literal>!defined</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:3280
msgid "<literal>ifmake</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:3286
msgid "<literal>ifnmake</literal>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:3288
msgid "<literal>!make</literal>"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3294
msgid ""
"There are also the <quote><literal>else if</literal></quote> forms: "
"<literal>elif</literal>, <literal>elifdef</literal>, <literal>elifndef</"
"literal>, <literal>elifmake</literal>, and <literal>elifnmake</literal>."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3299
msgid ""
"For instance, if you wish to create two versions of a program, one of which "
"is optimized (the production version) and the other of which is for "
"debugging (has symbols for dbx), you have two choices: you can create two "
"makefiles, one of which uses the <option>-g</option> flag for the "
"compilation, while the other uses the <option>-O</option> flag, or you can "
"use another target (call it debug) to create the debug version. The "
"construct below will take care of this for you. I have also made it so "
"defining the variable <envar>DEBUG</envar> (say with <command>pmake -D "
"DEBUG</command>) will also cause the debug version to be made."
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:3311
#, no-wrap
msgid ""
"#if defined(DEBUG) || make(debug)\n"
"CFLAGS         += -g\n"
"#else\n"
"CFLAGS         += -O\n"
"#endif"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3317
msgid ""
"There are, of course, problems with this approach. The most glaring "
"annoyance is that if you want to go from making a debug version to making a "
"production version, you have to remove all the object files, or you will get "
"some optimized and some debug versions in the same program. Another "
"annoyance is you have to be careful not to make two targets that "
"<quote>conflict</quote> because of some conditionals in the makefile. For "
"instance:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:3326
#, no-wrap
msgid ""
"#if make(print)\n"
"FORMATTER = ditroff -Plaser_printer\n"
"#endif\n"
"#if make(draft)\n"
"FORMATTER = nroff -Pdot_matrix_printer\n"
"#endif"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3333
msgid ""
"would wreak havoc if you tried <command>pmake draft print</command> since "
"you would use the same formatter for each target. As I said, this all gets "
"somewhat complicated."
msgstr ""

#. (itstool) path: section/title
#. (itstool) id: book.translate.xml#ashelltitle
#: book.translate.xml:3339
msgid "A Shell is a Shell is a Shell"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3341
msgid ""
"In normal operation, the Bourne Shell (better known as <application>sh</"
"application>) is used to execute the commands to re-create targets. "
"<application>PMake</application> also allows you to specify a different "
"shell for it to use when executing these commands. There are several things "
"<application>PMake</application> must know about the shell you wish to use. "
"These things are specified as the sources for the <_:buildtarget-1/> target "
"by keyword, as follows:"
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:3353
msgid "<literal>path=path</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3356
msgid ""
"<application>PMake</application> needs to know where the shell actually "
"resides, so it can execute it. If you specify this and nothing else, "
"<application>PMake</application> will use the last component of the path and "
"look in its table of the shells it knows and use the specification it finds, "
"if any. Use this if you just want to use a different version of the "
"<application>Bourne</application> or <application>C Shell</application> "
"(yes, <application>PMake</application> knows how to use the <application>C "
"Shell</application> too)."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:3371
msgid "<literal>name=name</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3374
msgid ""
"This is the name by which the shell is to be known. It is a single word and, "
"if no other keywords are specified (other than path), it is the name by "
"which <application>PMake</application> attempts to find a specification for "
"it (as mentioned above). You can use this if you would just rather use the C "
"Shell than the <application>Bourne Shell</application> (<literal>.SHELL: "
"name=csh</literal> will do it)."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:3386
msgid "<literal>quiet=echo-off</literal> command"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3389
msgid ""
"As mentioned before, <application>PMake</application> actually controls "
"whether commands are printed by introducing commands into the shell's input "
"stream. This keyword, and the next two, control what those commands are. The "
"<literal>quiet</literal> keyword is the command used to turn echoing off. "
"Once it is turned off, echoing is expected to remain off until the "
"<literal>echo-on</literal> command is given."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:3401
msgid "<literal>echo=echo-on</literal> command"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3404
msgid ""
"The command <application>PMake</application> should give to turn echoing "
"back on again."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:3410
msgid "<literal>filter=printed echo-off</literal> command"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3413
msgid ""
"Many shells will echo the <literal>echo-off</literal> command when it is "
"given. This keyword tells <application>PMake</application> in what format "
"the shell actually prints the <literal>echo-off</literal> command. Wherever "
"<application>PMake</application> sees this string in the shell's output, it "
"will delete it and any following whitespace, up to and including the next "
"newline. See the example at the end of this section for more details."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:3426
msgid "<literal>echoFlag=flag</literal> to turn echoing on"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3429
msgid ""
"Unless a target has been marked <literal>.SILENT</literal>, "
"<application>PMake</application> wants to start the shell running with "
"echoing on. To do this, it passes this flag to the shell as one of its "
"arguments. If either this or the next flag begins with a <literal>-</"
"literal>, the flags will be passed to the shell as separate arguments. "
"Otherwise, the two will be concatenated (if they are used at the same time, "
"of course)."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:3442
msgid "<literal>errFlag=flag</literal> to turn error checking on"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3445
msgid ""
"Likewise, unless a target is marked <literal>.IGNORE</literal>, "
"<application>PMake</application> wishes error-checking to be on from the "
"very start. To this end, it will pass this flag to the shell as an argument. "
"The same rules for an initial <literal>-</literal> apply as for the "
"<literal>echoFlag</literal>."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:3456
msgid "<literal>check=command</literal> to turn error checking on"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3459
msgid ""
"Just as for echo-control, error-control is achieved by inserting commands "
"into the shell's input stream. This is the command to make the shell check "
"for errors. It also serves another purpose if the shell does not have error-"
"control as commands, but I will get into that in a minute. Again, once error "
"checking has been turned on, it is expected to remain on until it is turned "
"off again."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:3471
msgid "<literal>ignore=command</literal>to turn error checking off"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3474
msgid ""
"This is the command <application>PMake</application> uses to turn error "
"checking off. It has another use if the shell does not do errorcontrol, but "
"I will tell you about that...now."
msgstr ""

#. (itstool) path: varlistentry/term
#: book.translate.xml:3482
msgid "<literal>hasErrCtl=yes</literal> or <literal>no</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3485
msgid ""
"This takes a value that is either <literal>yes</literal> or <literal>no</"
"literal>. Now you might think that the existence of the check and ignore "
"keywords would be enough to tell <application>PMake</application> if the "
"shell can do error-control, but you would be wrong. If <literal>hasErrCtl</"
"literal> is <literal>yes</literal>, <application>PMake</application> uses "
"the check and ignore commands in a straight-forward manner. If this is no, "
"however, their use is rather different. In this case, the check command is "
"used as a template, in which the string <literal>%s</literal> is replaced by "
"the command that is about to be executed, to produce a command for the shell "
"that will echo the command to be executed. The ignore command is also used "
"as a template, again with <literal>%s</literal> replaced by the command to "
"be executed, to produce a command that will execute the command to be "
"executed and ignore any error it returns. When these strings are used as "
"templates, you must provide newline(s) (<literal>\\n</literal>) in the "
"appropriate place(s)."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3510
msgid ""
"The strings that follow these keywords may be enclosed in single or double "
"quotes (the quotes will be stripped off) and may contain the usual C "
"backslash-characters (<literal>\\n</literal> is newline, <literal>\\r</"
"literal> is return, <literal>\\b</literal> is backspace, <literal>\\'</"
"literal> escapes a single-quote inside single-quotes, <literal>\\\"</"
"literal> escapes a double-quote inside double-quotes). Now for an example."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3519
msgid ""
"This is actually the contents of the &lt;shx.mk&gt; system makefile, and "
"causes <application>PMake</application> to use the <application>Bourne "
"Shell</application> in such a way that each command is printed as it is "
"executed. That is, if more than one command is given on a line, each will be "
"printed separately. Similarly, each time the body of a loop is executed, the "
"commands within that loop will be printed, etc. The specification runs like "
"this:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:3528
#, no-wrap
msgid ""
"#\n"
"# This is a shell specification to have the Bourne shell echo\n"
"# the commands just before executing them, rather than when it reads\n"
"# them. Useful if you want to see how variables are being expanded, etc.\n"
"#\n"
".SHELL    : path=/bin/sh \\\n"
"     quiet=\"set -\" \\\n"
"     echo=\"set -x\" \\\n"
"     filter=\"+ set - \" \\\n"
"     echoFlag=x \\\n"
"     errFlag=e \\\n"
"     hasErrCtl=yes \\\n"
"     check=\"set -e\" \\\n"
"     ignore=\"set +e\""
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3543
msgid "It tells <application>PMake</application> the following:"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3547
msgid ""
"The shell is located in the file <filename>/bin/sh</filename>. It need not "
"tell <application>PMake</application> that the name of the shell is sh as "
"<application>PMake</application> can figure that out for itself (it is the "
"last component of the path)."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3556
msgid "The command to stop echoing is set <literal>-</literal>."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3560
msgid "The command to start echoing is set <option>-x</option>."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3564
msgid ""
"When the echo off command is executed, the shell will print <literal>+</"
"literal> set <literal>-</literal> (The <literal>+</literal> comes from using "
"the <option>-x</option> flag (rather than the <option>-v</option> flag "
"<application>PMake</application> usually uses)). <application>PMake</"
"application> will remove all occurrences of this string from the output, so "
"you do not notice extra commands you did not put there."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3576
msgid ""
"The flag the <application>Bourne Shell</application> will take to start "
"echoing in this way is the <option>-x</option> flag. The <application>Bourne "
"Shell</application> will only take its flag arguments concatenated as its "
"first argument, so neither this nor the errFlag specification begins with a "
"<literal>-</literal>."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3586
msgid ""
"The flag to use to turn error-checking on from the start is <option>-e</"
"option>."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3591
msgid ""
"The shell can turn error-checking on and off, and the commands to do so are "
"<literal>set +e</literal> and <literal>set -e</literal>, respectively."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3597
msgid ""
"I should note that this specification is for <application>Bourne Shells</"
"application> that are not part of Berkeley <trademark class="
"\"registered\">UNIX</trademark>, as shells from Berkeley do not do error "
"control. You can get a similar effect, however, by changing the last three "
"lines to be:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:3603
#, no-wrap
msgid ""
"hasErrCtl=no \\\n"
"check=\"echo \\\"+ %s\\\"\\n\" \\\n"
"ignore=\"sh -c '%s || exit 0\\n\""
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3607
msgid ""
"This will cause <application>PMake</application> to execute the two commands:"
""
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:3610
#, no-wrap
msgid "echo \"+ cmd\"\n"
"sh -c 'cmd || true'"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3613
msgid ""
"for each command for which errors are to be ignored. (In case you are "
"wondering, the thing for ignore tells the shell to execute another shell "
"without error checking on and always exit 0, since the ||<literal/> causes "
"the exit 0 to be executed only if the first command exited non-zero, and if "
"the first command exited zero, the shell will also exit zero, since that is "
"the last command it executed)."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:3624
msgid "Compatibility"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3626
msgid ""
"There are three (well, 3 1/2) levels of backwards-compatibility built into "
"<application>PMake</application>. Most makefiles will need none at all. Some "
"may need a little bit of work to operate correctly when run in parallel. "
"Each level encompasses the previous levels (e.g. <option>-B</option> (one "
"shell per command) implies <option>-V</option>). The three levels are "
"described in the following three sections."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:3637
msgid "DEFCON 3 – Variable Expansion"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3639
msgid ""
"As noted before, <application>PMake</application> will not expand a variable "
"unless it knows of a value for it. This can cause problems for makefiles "
"that expect to leave variables undefined except in special circumstances (e."
"g. if more flags need to be passed to the C compiler or the output from a "
"text processor should be sent to a different printer). If the variables are "
"enclosed in curly braces (<literal>${PRINTER}</literal>), the shell will let "
"them pass. If they are enclosed in parentheses, however, the shell will "
"declare a syntax error and the make will come to a grinding halt."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3651
msgid ""
"You have two choices: change the makefile to define the variables (their "
"values can be overridden on the command line, since that is where they would "
"have been set if you used <application>Make</application>, anyway) or always "
"give the <option>-V</option> flag (this can be done with the <_:buildtarget-"
"1/> target, if you want)."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:3660
msgid "DEFCON 2 – The Number of the Beast"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3662
msgid ""
"Then there are the makefiles that expect certain commands, such as changing "
"to a different directory, to not affect other commands in a target's "
"creation script. You can solve this is either by going back to executing one "
"shell per command (which is what the <option>-B</option> flag forces "
"<application>PMake</application> to do), which slows the process down a good "
"bit and requires you to use semicolons and escaped newlines for shell "
"constructs, or by changing the makefile to execute the offending command(s) "
"in a subshell (by placing the line inside parentheses), like so:"
msgstr ""

#. (itstool) path: section/programlisting
#: book.translate.xml:3674
#, no-wrap
msgid ""
"install :: .MAKE\n"
"      (cd src; $(.PMAKE) install)\n"
"      (cd lib; $(.PMAKE) install)\n"
"      (cd man; $(.PMAKE) install)"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3679
msgid ""
"This will always execute the three makes (even if the <option>-n</option> "
"flag was given) because of the combination of the <literal>::</literal> "
"operator and the <literal>.MAKE</literal> attribute. Each command will "
"change to the proper directory to perform the install, leaving the main "
"shell in the directory in which it started."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:3690
msgid "DEFCON 1 – Imitation is the Not the Highest Form of Flattery"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3693
msgid ""
"The final category of makefile is the one where every command requires "
"input, the dependencies are incompletely specified, or you simply cannot "
"create more than one target at a time, as mentioned earlier. In addition, "
"you may not have the time or desire to upgrade the makefile to run smoothly "
"with <application>PMake</application>. If you are the conservative sort, "
"this is the compatibility mode for you. It is entered either by giving "
"<application>PMake</application> the <option>-M</option> flag (for "
"<application>Make</application>), or by executing <application>PMake</"
"application> as <command>make.</command> In either case, <application>PMake</"
"application> performs things exactly like <application>Make</application> "
"(while still supporting most of the nice new features <application>PMake</"
"application> provides). This includes:"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3711
msgid "No parallel execution."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3715
msgid ""
"Targets are made in the exact order specified by the makefile. The sources "
"for each target are made in strict left-to-right order, etc."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3721
msgid ""
"A single Bourne shell is used to execute each command, thus the shell's "
"<varname>$$</varname> variable is useless, changing directories does not "
"work across command lines, etc."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3728
msgid ""
"If no special characters exist in a command line, <application>PMake</"
"application> will break the command into words itself and execute the "
"command directly, without executing a shell first. The characters that cause "
"<application>PMake</application> to execute a shell are: <literal>#</"
"literal>, <literal>=</literal>, <literal>|</literal>, <literal>^</literal>, "
"<literal>(</literal>, <literal>)</literal>, <literal>{</literal>, "
"<literal>}</literal>, <literal>;</literal>, <literal>&amp;</literal>, "
"<literal>&gt;</literal>, <literal>&lt;</literal>, <literal>*</literal>, "
"<literal>?</literal>, <literal>[</literal>, <literal>]</literal>, <literal>:"
"</literal>, <literal>$</literal>, <literal>`</literal>, and <literal>\\</"
"literal>. You should notice that these are all the characters that are given "
"special meaning by the shell (except <literal>'</literal> and <literal>,</"
"literal> which <application>PMake</application> deals with all by its "
"lonesome)."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:3751
msgid "The use of the null suffix is turned off."
msgstr ""

#. (itstool) path: section/title
#: book.translate.xml:3757
msgid "The Way Things Work"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3759
msgid ""
"When <application>PMake</application> reads the makefile, it parses sources "
"and targets into nodes in a graph. The graph is directed only in the sense "
"that <application>PMake</application> knows which way is up. Each node "
"contains not only links to all its parents and children (the nodes that "
"depend on it and those on which it depends, respectively), but also a count "
"of the number of its children that have already been processed."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3767
msgid ""
"The most important thing to know about how <application>PMake</application> "
"uses this graph is that the traversal is breadth-first and occurs in two "
"passes."
msgstr ""

#. (itstool) path: para/buildtarget
#: book.translate.xml:3782 book.translate.xml:3786 book.translate.xml:3788
#: book.translate.xml:3789
msgid ".USE"
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3771
msgid ""
"After <application>PMake</application> has parsed the makefile, it begins "
"with the nodes the user has told it to make (either on the command line, or "
"via a <_:buildtarget-1/> target, or by the target being the first in the "
"file not labeled with the <literal>.NOTMAIN</literal> attribute) placed in a "
"queue. It continues to take the node off the front of the queue, mark it as "
"something that needs to be made, pass the node to <literal>Suff_FindDeps</"
"literal> (mentioned earlier) to find any implicit sources for the node, and "
"place all the node's children that have yet to be marked at the end of the "
"queue. If any of the children is a <_:buildtarget-2/> rule, its attributes "
"are applied to the parent, then its commands are appended to the parent's "
"list of commands and its children are linked to its parent. The parent's "
"unmade children counter is then decremented (since the <_:buildtarget-3/> "
"node has been processed). You will note that this allows a <_:buildtarget-4/"
"> node to have children that are <_:buildtarget-5/> nodes and the rules will "
"be applied in sequence. If the node has no children, it is placed at the end "
"of another queue to be examined in the second pass. This process continues "
"until the first queue is empty."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3794
msgid ""
"At this point, all the leaves of the graph are in the examination queue. "
"<application>PMake</application> removes the node at the head of the queue "
"and sees if it is out-of-date. If it is, it is passed to a function that "
"will execute the commands for the node asynchronously. When the commands "
"have completed, all the node's parents have their unmade children counter "
"decremented and, if the counter is then 0, they are placed on the "
"examination queue. Likewise, if the node is up-to-date. Only those parents "
"that were marked on the downward pass are processed in this way. Thus "
"<application>PMake</application> traverses the graph back up to the nodes "
"the user instructed it to create. When the examination queue is empty and no "
"shells are running to create a target, <application>PMake</application> is "
"finished."
msgstr ""

#. (itstool) path: section/para
#: book.translate.xml:3809
msgid ""
"Once all targets have been processed, <application>PMake</application> "
"executes the commands attached to the <_:buildtarget-1/> target, either "
"explicitly or through the use of an ellipsis in a shell script. If there "
"were no errors during the entire process but there are still some targets "
"unmade (<application>PMake</application> keeps a running count of how many "
"targets are left to be made), there is a cycle in the graph. "
"<application>PMake</application> does a depth-first traversal of the graph "
"to find all the targets that were not made and prints them out one by one."
msgstr ""

#. (itstool) path: chapter/title
#: book.translate.xml:3827
msgid "Answers to Exercises"
msgstr ""

#. (itstool) path: chapter/para
#: book.translate.xml:3831
msgid ""
"This is something of a trick question, for which I apologize. The trick "
"comes from the <trademark class=\"registered\">UNIX</trademark> definition "
"of a suffix, which <application>PMake</application> does not necessarily "
"share. You will have noticed that all the suffixes used in this tutorial "
"(and in <trademark class=\"registered\">UNIX</trademark> in general) begin "
"with a period (<filename>.ms</filename>, <filename>.c</filename>, etc.). "
"Now, <application>PMake</application>'s idea of a suffix is more like "
"English's: it is the characters at the end of a word. With this in mind, one "
"possible solution to this problem goes as follows:"
msgstr ""

#. (itstool) path: chapter/programlisting
#: book.translate.xml:3842
#, no-wrap
msgid ""
".SUFFIXES       : ec.exe .exe ec.obj .obj .asm\n"
"ec.objec.exe .obj.exe :\n"
"\tlink -o $(.TARGET) $(.IMPSRC)\n"
".asmec.obj      :\n"
"\tasm -o $(.TARGET) -DDO_ERROR_CHECKING $(.IMPSRC)\n"
".asm.obj        :\n"
"\tasm -o $(.TARGET) $(.IMPSRC)"
msgstr ""

#. (itstool) path: chapter/bridgehead
#: book.translate.xml:3850
msgid "Excercise 3.2"
msgstr ""

#. (itstool) path: chapter/para
#: book.translate.xml:3852
msgid ""
"The trick to this one lies in the <literal>:=</literal> variable-assignment "
"operator and the <literal>:S</literal> variable-expansion modifier. "
"Basically what you want is to take the pointer variable, so to speak, and "
"transform it into an invocation of the variable at which it points. You "
"might try something like:"
msgstr ""

#. (itstool) path: chapter/programlisting
#: book.translate.xml:3859
#, no-wrap
msgid "$(PTR:S/^/\\$(/:S/$/))"
msgstr ""

#. (itstool) path: chapter/para
#: book.translate.xml:3861
msgid ""
"which places <literal>$(</literal> at the front of the variable name and "
"<literal>)</literal> at the end, thus transforming <literal>VAR,</literal> "
"for example, into <literal>$(VAR)</literal>, which is just what we want. "
"Unfortunately (as you know if you have tried it), since, as it says in the "
"hint, <application>PMake</application> does no further substitution on the "
"result of a modified expansion, that is all you get. The solution is to make "
"use of <literal>:=</literal> to place that string into yet another variable, "
"then invoke the other variable directly:"
msgstr ""

#. (itstool) path: chapter/programlisting
#: book.translate.xml:3872
#, no-wrap
msgid "*PTR            := $(PTR:S/^/\\$(/:S/$/)/)"
msgstr ""

#. (itstool) path: chapter/para
#: book.translate.xml:3874
msgid "You can then use <literal>$(*PTR)</literal> to your heart's content."
msgstr ""

#. (itstool) path: glossary/title
#: book.translate.xml:3884
msgid "Glossary of Jargon"
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3887
msgid "attribute"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:3890
msgid ""
"A property given to a target that causes <application>PMake</application> to "
"treat it differently."
msgstr ""

#. (itstool) path: glossentry/glossterm
#. (itstool) id: book.translate.xml#cmdscript
#: book.translate.xml:3896
msgid "command script"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:3899
msgid ""
"The lines immediately following a dependency line that specify commands to "
"execute to create each of the targets on the dependency line. Each line in "
"the command script must begin with a tab."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3906
msgid "command-line variable"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:3909
msgid ""
"A variable defined in an argument when <application>PMake</application> is "
"first executed. Overrides all assignments to the same variable name in the "
"makefile."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3917
msgid "conditional"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:3920
msgid ""
"A construct much like that used in C that allows a makefile to be configured "
"on the fly based on the local environment, or on what is being made by that "
"invocation of <application>PMake</application>."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3927
msgid "creation script"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:3930
msgid "Commands used to create a target."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3935
msgid "dependency"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:3938
msgid ""
"The relationship between a source and a target. This comes in three flavors, "
"as indicated by the operator between the target and the source. <literal>:</"
"literal> gives a straight time-wise dependency (if the target is older than "
"the source, the target is out-of-date), while <literal>!</literal> provides "
"simply an ordering and always considers the target out-of-date. <literal>::</"
"literal> is much like <literal>:</literal>, save it creates multiple "
"instances of a target each of which depends on its own list of sources."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3950
msgid "dynamic source"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:3953
msgid ""
"This refers to a source that has a local variable invocation in it. It "
"allows a single dependency line to specify a different source for each "
"target on the line."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3960
msgid "global variable"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:3963
msgid ""
"Any variable defined in a makefile. Takes precedence over variables defined "
"in the environment, but not over command-line or local variables."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3970
msgid "input graph"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:3973
msgid ""
"What <application>PMake</application> constructs from a makefile. Consists "
"of nodes made of the targets in the makefile, and the links between them "
"(the dependencies). The links are directed (from source to target) and there "
"may not be any cycles (loops) in the graph."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3981
msgid "local variable"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:3984
msgid ""
"A variable defined by <application>PMake</application> visible only in a "
"target's shell script. There are seven local variables, not all of which are "
"defined for every target: <varname>.TARGET</varname>, <varname>.ALLSRC</"
"varname>, <varname>.OODATE</varname>, <varname>.PREFIX</varname>, <varname>."
"IMPSRC</varname>, <varname>.ARCHIVE</varname>, and <varname>.MEMBER</"
"varname>. <varname>.TARGET</varname>, <varname>.PREFIX</varname>, <varname>."
"ARCHIVE</varname>, and <varname>.MEMBER</varname> may be used on dependency "
"lines to create <quote>dynamic sources</quote>."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3999
msgid "makefile"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:4002
msgid ""
"A file that describes how a system is built. If you do not know what it is "
"after reading this tutorial…"
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4008
msgid "modifier"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:4011
msgid ""
"A letter, following a colon, used to alter how a variable is expanded. It "
"has no effect on the variable itself."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4017
msgid "operator"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:4020
msgid ""
"What separates a source from a target (on a dependency line) and specifies "
"the relationship between the two. There are three: <literal>:</literal>, "
"<literal>::</literal>, and <literal>!</literal>."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4028
msgid "search path"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:4031
msgid ""
"A list of directories in which a file should be sought. <application>PMake</"
"application>'s view of the contents of directories in a search path does not "
"change once the makefile has been read. A file is sought on a search path "
"only if it is exclusively a source."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4040
msgid "shell"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:4043
msgid "A program to which commands are passed in order to create targets."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4049
msgid "source"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:4052
msgid ""
"Anything to the right of an operator on a dependency line. Targets on the "
"dependency line are usually created from the sources."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4059
msgid "special target"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:4062
msgid ""
"A target that causes <application>PMake</application> to do special things "
"when it is encountered."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4068
msgid "suffix"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:4071
msgid ""
"The tail end of a file name. Usually begins with a period, like <filename>."
"c</filename> or <filename>.ms</filename>."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4077
msgid "target"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:4080
msgid ""
"A word to the left of the operator on a dependency line. More generally, any "
"file that <application>PMake</application> might create. A file may be (and "
"often is) both a target and a source (what it is depends on how "
"<application>PMake</application> is looking at it at the time – sort of like "
"the wave/particle duality of light, you know)."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4090
msgid "transformation rule"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:4093
msgid ""
"A special construct in a makefile that specifies how to create a file of one "
"type from a file of another, as indicated by their suffixes."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4100
msgid "variable expansion"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:4103
msgid ""
"The process of substituting the value of a variable for a reference to it. "
"Expansion may be altered by means of modifiers."
msgstr ""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4109
msgid "variable"
msgstr ""

#. (itstool) path: glossdef/para
#: book.translate.xml:4112
msgid ""
"A place in which to store text that may be retrieved later. Also used to "
"define the local environment. Conditionals exist that test whether a "
"variable is defined or not."
msgstr ""
